# Avoid dependencies amongst details arguments {#args-independence}

```{r, include = FALSE}
source("common.R")
```

## What's the problem?

Avoid creating dependencies between details arguments so that only certain combinations are permitted.

## What's an example?

* In `var()`, `na.rm` is only used if `use` is not set. If you supply both 
  `use` and `na.rm`, `na.rm` is silently ignored.

* In `ggplot2::geom_histogram()` you can specify the histogram breaks in 
  three ways: as a number of `bins`,  as the width of each bin (`binwidth`, 
  plus `center` and `boundary`), or the exact `breaks`. You can only pick 
  one of the three options, which is hard to convey in the documentation.
  There's also an implied precedence so that if more than one option is 
  supplied, one will silently win.

* `grepl()` has `perl`, `fixed,` and `ignore.case` arguments which can
  either be `TRUE` or `FALSE`. But `fixed = TRUE` overrides `perl = TRUE`, 
  and `ignore.case` only works if `fixed = FALSE`.

Often these problems arise because when the functions were originally designed the scope was much smaller. It grew gradually over time, and no point did it seem worth the additional effort to refactor to a new design.

## How do I remediate?

Create new argument. Deprecate old args with warnings that tell you how to use the new (preferrably with code to copy and paste).

### Case study: `grepl()` vs `stringr::str_detect()`

<!-- 
https://github.com/wch/r-source/blob/trunk/src/main/grep.c#L891-L1151 -->

`grepl()`, has three arguments that take either `FALSE` or `TRUE`: `ignore.case`, `perl`, `fixed`, which might suggest that there are 2 ^ 3 = 16 possible invocations. However, a number of combinations are not allowed:

```{r}
x <- grepl("a", letters, fixed = TRUE, ignore.case = TRUE)
x <- grepl("a", letters, fixed = TRUE, perl = TRUE)
```

Part of this problem could be resolved by making it more clear that one important choice is the matching engine to use:  POSIX 1003.2 extended regular expressions (the default), Perl-style regular expressions (`perl = TRUE`) or fixed matching (`fixed = TRUE`). A better approach would be to use the pattern in Chapter \@ref(args-enum), and create a new argument called something like `engine = c("POSIX", "perl", "fixed")`.

The other problem is that `ignore.case` can only affect two of the three engines: POSIX and perl. This is hard to remedy without creating a completely new matching engine. Anything to do with case is always harder than you might expect because different languages have different rules.

stringr takes a different approach, encoding the engine as an attribute of the pattern:

```{r}
library(stringr)

x <- str_detect(letters, "a")
# short for:
x <- str_detect(letters, regex("a"))
x <- str_detect(letters, fixed("a"))
x <- str_detect(letters, coll("a"))
```

This has the advantage that each engine can take different arguments. 

An alternative approach would be to have a separate engine argument:

```{r, eval = FALSE}
x <- str_detect(letters, "a", engine = regex())
x <- str_detect(letters, "a", engine = fixed())
x <- str_detect(letters, "a", engine = coll())
```

This approach is a bit more discoverable (because there's clearly another argument that affects the pattern), but it's slightly less general, because of the `boundary()` engine, which doesn't match patterns but boundaries:

```{r, eval = FALSE}
x <- str_detect(letters, boundary("word"))
# Seems confusing: now you can omit the pattern argument?
x <- str_detect(letters, engine = boundary("word"))
```

It's appealing to all the details of the match wrapped up into a single object. 

### Case study: `ggplot2::geom_histogram()`



