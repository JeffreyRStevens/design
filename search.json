[{"path":"index.html","id":"welcome","chapter":"Welcome","heading":"Welcome","text":"goal book help write better R code. four main components:Design problems lead suboptimal outcomes.Design problems lead suboptimal outcomes.Useful patterns help solve common problems.Useful patterns help solve common problems.Key principles help balance conflicting patterns.Key principles help balance conflicting patterns.Selected case studies help see pieces fit together\nreal code.Selected case studies help see pieces fit together\nreal code.used tidyverse team promote consistency across packages core tidyverse. can also use guide design functions packages create interfaces feel “tidy”, fit natural code uses tidyverse idioms. complement http://style.tidyverse.org, focusses low-level code formatting.book heavy development quite time; currently loosely aiming completion 2020. ’ll find many chapters contain disjointed text mostly serve placeholders authors, recommend attempting systematically read book time.","code":""},{"path":"structure.html","id":"structure","chapter":"1 Structure","heading":"1 Structure","text":"","code":""},{"path":"structure.html","id":"implementation","chapter":"1 Structure","heading":"1.1 Implementation","text":"","code":""},{"path":"structure.html","id":"interface","chapter":"1 Structure","heading":"1.2 Interface","text":"interface function describes interfaces world, independent internal implementation.","code":""},{"path":"structure.html","id":"inputs","chapter":"1 Structure","heading":"1.2.1 Inputs","text":"Chapter 6: inputs function explicit\narguments. Avoid functions suprise user returning different\nresults inputs look .Chapter 6: inputs function explicit\narguments. Avoid functions suprise user returning different\nresults inputs look .Chapter 7: Required arguments come \noptional arguments.Chapter 7: Required arguments come \noptional arguments.Chapter 8: Make arguments orthogonal possible.\nAvoid complex interdependencies.Chapter 8: Make arguments orthogonal possible.\nAvoid complex interdependencies.","code":""},{"path":"structure.html","id":"default-values","chapter":"1 Structure","heading":"1.2.1.1 Default values","text":"Chapter 10: absence default value indicate\nargument required; presence default value indicate\nargument optional.Chapter 10: absence default value indicate\nargument required; presence default value indicate\nargument optional.Chapter 12: details argument can take one fixed set\npossible strings, record default value use match.arg()\nrlang::arg_match() inside function.Chapter 12: details argument can take one fixed set\npossible strings, record default value use match.arg()\nrlang::arg_match() inside function.Chapter 13: Default values return \nanswer set directly.Chapter 13: Default values return \nanswer set directly.Chapter 14: Default values short. \ncomplex calculation, either use NULL exported function.Chapter 14: Default values short. \ncomplex calculation, either use NULL exported function.Chapter 15: default value particularly important,\nnon-trivial calculation, let user know .Chapter 15: default value particularly important,\nnon-trivial calculation, let user know .Chapter 16: Use getOption() allow user \nset default values.Chapter 16: Use getOption() allow user \nset default values.","code":""},{"path":"structure.html","id":"dots","chapter":"1 Structure","heading":"1.2.1.2 Dots","text":"Chapter 18: ... placed data \ndetails arguments.Chapter 18: ... placed data \ndetails arguments.Chapter 19: don’t use ... just save user typing\nc() (unless function purely data structure creation).Chapter 19: don’t use ... just save user typing\nc() (unless function purely data structure creation).Chapter 20: carefully consider arguments need \n. prefix order reduce chance spurious matches.Chapter 20: carefully consider arguments need \n. prefix order reduce chance spurious matches.Chapter 21: using ... S3 methods, passing \nfunctions silently ignore mismatches, check inputs \n... evaluated.Chapter 21: using ... S3 methods, passing \nfunctions silently ignore mismatches, check inputs \n... evaluated.","code":""},{"path":"structure.html","id":"output","chapter":"1 Structure","heading":"1.2.2 Output","text":"Chapter 26: functions called primarily \nside-effects invisibly return useful value.","code":""},{"path":"structure.html","id":"errors","chapter":"1 Structure","heading":"1.2.3 Errors","text":"Chapter 27: don’t display call generating error\nmessage.Chapter 27: don’t display call generating error\nmessage.Chapter 28: error generated multiple\nfunctions, extract function, \nerror constructor.Chapter 28: error generated multiple\nfunctions, extract function, \nerror constructor.","code":""},{"path":"structure.html","id":"side-effects","chapter":"1 Structure","heading":"1.2.4 Side-effects","text":"Chapter 30: mixing side-effects computation \nsingle function makes functions hard reason hard\nprogram .Chapter 30: mixing side-effects computation \nsingle function makes functions hard reason hard\nprogram .Chapter 31: function side-effects, \nconstrained lie beneath current scope.Chapter 31: function side-effects, \nconstrained lie beneath current scope.","code":""},{"path":"unifying-principles.html","id":"unifying-principles","chapter":"2 Unifying principles","heading":"2 Unifying principles","text":"tidyverse language solving data science challenges R code. primary goal facilitate conversation human dataset, want help dig “pit success” least-effort path trends towards positive outcome. primary tool dig pit API design: carefully considering external interface function, can help guide user towards success. ’s also necessary high level principles guide think broadly APIs, principles can use “break ties” factors balanced.tidyverse four guiding principles:human centered, .e. tidyverse designed specifically \nsupport activities human data analyst.human centered, .e. tidyverse designed specifically \nsupport activities human data analyst.consistent, learn one function package\ncan applied another, number special cases need\nremember small possible.consistent, learn one function package\ncan applied another, number special cases need\nremember small possible.composable, allowing solve complex problems breaking\nsmall pieces, supporting rapid cycle exploratory\niteration find best solution.composable, allowing solve complex problems breaking\nsmall pieces, supporting rapid cycle exploratory\niteration find best solution.inclusive, tidyverse just collection \npackages, also community people use .inclusive, tidyverse just collection \npackages, also community people use .guiding principles aspirational; ’re always fully realised current tidyverse packages, strive make .","code":""},{"path":"unifying-principles.html","id":"related-work","chapter":"2 Unifying principles","heading":"Related work","text":"principles inspired writings design systems: :Unix philsophyThe Zen PythonDesign Principles Behind Smalltalk","code":""},{"path":"unifying-principles.html","id":"human-centered","chapter":"2 Unifying principles","heading":"2.1 Human centered","text":"Programs must written people read, incidentally\nmachines execute.— Hal AbelsonProgramming task performed humans. create effective programming tools must explicitly recognise acknowledge role played cognitive psychology. particularly important R, ’s language ’s used primarily non-programmers, want make easy possible first-time end-user programmers learn tidyverse.particularly useful tool cognitive psychology “cognitive load theory”1: limited working memory, anything can reduce extraneous cognitive load helps learner user tidyverse. motivates next two principles:consistent need learn internalise one\nexpression idea, can apply many times.consistent need learn internalise one\nexpression idea, can apply many times.composable can break complex problems bite sized\npieces can easily hold head.composable can break complex problems bite sized\npieces can easily hold head.Idea “chunking” important. setup cost learn new chunk, ’ve internalised , takes one spot working memory. sense goal tidyverse discover minimal set chunks needed data science sense priority remainder.useful ideas come design. One particularly powerful idea “affordance”: exterior tool suggest use . want avoid “Norman doors” exterior clues cues point wrong direction.principle deeply connected beliefs performance. importantly performance code depends long takes run, also long takes write read. Human brains typically slower computers, means spend lot time thinking create intuitve interfaces, focussing writing reading speed. Intuitive interfaces sometimes odds running speed, writing fastest code problem often requires designing interface performance rather usability. Generally, optimise first humans, use profiling discover bottlenecks cause friction data analysis. identified important bottleneck, performance becomes priority rewrite existing code. Generally, ’ll attempt preserve existing interface, changing performance implications significant.","code":""},{"path":"unifying-principles.html","id":"consistent","chapter":"2 Unifying principles","heading":"2.2 Consistent","text":"system built minimum set unchangeable parts;\nparts general possible; parts \nsystem held uniform framework.— Daniel H. H. IngallsThe important API principle tidyverse consistent. want find smallest possible set key ideas use . important makes tidyverse easier learn remember.(Another framing principle Less Volume, Creativity, comes Mike McCarthy, head coach Green Bay Packers, popularised Statistics Education Randall Pruim)related one favourite saying Python community:one—preferably one—obvious way .— Zen PythonThe tidyverse aspires put philosophy practice. However, tidyverse embedded within larger R ecosystem, applying principle never needs 100% comprehensive. can’t solve problem within tidyverse, can always step outside base R another package. also means don’t rush cover every possible use case; can take time develop best new solutions.principle consistency reveals two primary ways: function APIs data structures. API function defines external interface (independent internal implementation). consistent APIs means time learn function, learning next function little easier; ’ve mastered one package, mastering next easier.two ways make functions consistent important ’re explicitly pull high-level principles :Functions composable: individual function tackle\none well contained problem, solve complex real-world problems \ncomposing many individual functions.Functions composable: individual function tackle\none well contained problem, solve complex real-world problems \ncomposing many individual functions.Overall, API feel “functional”, technical term \nprogramming paradigm favoured tidyverseOverall, API feel “functional”, technical term \nprogramming paradigm favoured tidyverseBut consistency also applies data structures: want ensure use data structures . Principally, expect data stored tidy data frames tibbles. means tools converting formats can centralised one place, packages development simplified assuming data already standard format.Valuing consistency trade-, explicitly value performance. cases different data structure different interface might make solution simpler express much faster. However, one-solutions create much higher cognitive load.","code":""},{"path":"unifying-principles.html","id":"composable","chapter":"2 Unifying principles","heading":"2.3 Composable","text":"matter complex polished individual operations ,\noften quality glue directly determines\npower system.— Hal AbelsonA powerful strategy solving complex problems combine many simple pieces. piece easily understood isolation, standard way combining pieces.Within tidyverse, prefer compose functions using single tool: pipe, %>%. two notable exceptions principle: ggplot2 composes graphical elements +, httr composes requests primarily .... bad techniques isolation, well suited domains used, disadvantages inconsistency outweigh local advantages.smaller domains, means carefully designing functions inputs outputs align (e.g. output stringr::str_locate() can easily fed str_sub()). middling domains, means drawing many feature matrices ensuring dense (e.g. consider map family purrr). larger domains, means carefully thinking algebras grammars, identifying atoms problem ways might composed solve bigger problems.decompose large problems smaller, tractable ones creating combining functions transform data rather creating objects whose state changes time.techniques tend facilitate composability:Functions data: leads impactful techniques \nfunctional programming, allow reduce code duplication.Functions data: leads impactful techniques \nfunctional programming, allow reduce code duplication.Immutable objects. Enforces independence components.Immutable objects. Enforces independence components.Partition side-effects.Partition side-effects.Type-stable.Type-stable.","code":""},{"path":"unifying-principles.html","id":"inclusive","chapter":"2 Unifying principles","heading":"2.4 Inclusive","text":"value just interface human computer, also interface humans. want tidyverse diverse, inclusive, welcoming community.develop educational materials accessible people many\ndifferent skill levels.develop educational materials accessible people many\ndifferent skill levels.prefer explicit codes conduct.prefer explicit codes conduct.create safe friendly communities. believe kindness \ncore value communities.create safe friendly communities. believe kindness \ncore value communities.think can help others like us\n(may visually impaired may speak English).think can help others like us\n(may visually impaired may speak English).also appreciate paradox tolerance: people welcome intolerant.","code":""},{"path":"names-attribute.html","id":"names-attribute","chapter":"3 Names attribute","heading":"3 Names attribute","text":"","code":""},{"path":"names-attribute.html","id":"coverage-in-tidyverse-style-guide","chapter":"3 Names attribute","heading":"3.1 Coverage in tidyverse style guide","text":"Existing name-related topics http://style.tidyverse.orgFile namesObject namesArgument namesFunction names","code":""},{"path":"names-attribute.html","id":"the-names-attribute-of-an-object","chapter":"3 Names attribute","heading":"3.2 The names attribute of an object","text":"address manage names attribute object. initial thinking motivated handle column variable names tibble, evolving name-handling strategy vectors, general.name repair described exposed users via .name_repair argument tibble::tibble(), tibble::as_tibble(), readxl::read_excel(), , eventually packages tidyverse. work initiated tibble package, migrating vctrs package. Name repair first introduced tibble v2.0.0 write-rendered tibble v3.1.8 vctrs v0.5.0.kind names ’re talking :","code":"\n## variable names\nnames(iris)\n#> [1] \"Sepal.Length\" \"Sepal.Width\"  \"Petal.Length\" \"Petal.Width\"  \"Species\"\n\nnames(ChickWeight)\n#> [1] \"weight\" \"Time\"   \"Chick\"  \"Diet\"\n\n## names along a vector\nnames(euro)\n#>  [1] \"ATS\" \"BEF\" \"DEM\" \"ESP\" \"FIM\" \"FRF\" \"IEP\" \"ITL\" \"LUF\" \"NLG\" \"PTE\""},{"path":"names-attribute.html","id":"minimal-unique-universal","chapter":"3 Names attribute","heading":"3.3 Minimal, unique, universal","text":"identify three nested levels naminess practically useful:Minimal: names attribute NULL. name unnamed element\n\"\" (empty string) never NA.Unique: element names appears . couple specific\nnames also forbidden unique names, \"\" (empty string).\ncolumns can accessed name via df[[\"name\"]] , \ngenerally, quoting backticks: df$`name`,\nsubset(df, select = `name`), dplyr::select(df, `name`).\ncolumns can accessed name via df[[\"name\"]] , \ngenerally, quoting backticks: df$`name`,\nsubset(df, select = `name`), dplyr::select(df, `name`).Universal: names unique syntactic.\nNames work everywhere, without quoting: df$name \nlm(name1 ~ name2, data = df) dplyr::select(df, name) work.\nNames work everywhere, without quoting: df$name \nlm(name1 ~ name2, data = df) dplyr::select(df, name) work.give details describe implementation.","code":""},{"path":"names-attribute.html","id":"minimal-names","chapter":"3 Names attribute","heading":"3.4 Minimal names","text":"Minimal names exist. names attribute NULL. name unnamed element \"\" (empty string) never NA.Consider unnamed vector, .e. names attribute NULL.Repair names make minimal.Minimal names appear useful baseline requirement, names attribute object going actively managed. ? General name handling repair can implemented simply baseline strategy guarantees names(x) returns character vector correct length NAs.also reasonable interpretation base R’s intent named vectors, based docs names(), although base R’s implementation/enforcement uneven. ?names:name \"\" special: used indicate name\nassociated element (atomic generic) vector. Subscripting \n\"\" match nothing (even elements name).name can character NA, name never matched \nlikely lead confusion.tbl_df objects created tibble::tibble() tibble::as_tibble() variable names minimal, least.function rlang::names2() returns names object, making minimal.","code":"\nx <- letters[1:3]\nnames(x)\n#> NULL\n# TODO: Figure out where `set_minimal_names()` ended up when name repair moved\n# from tibble to vctrs, then update this chunk. Use rlang in the meantime.\n\n# x <- tibble:::set_minimal_names(x)\nx <- rlang::set_names(x, rlang::names2(x))\nnames(x)\nx <- letters[1:3]\n\nnames(x)\n#> NULL\n\nrlang::names2(x)\n#> [1] \"\" \"\" \"\""},{"path":"names-attribute.html","id":"unique-names","chapter":"3 Names attribute","heading":"3.5 Unique names","text":"Unique names meet requirements minimal duplicates. tidyverse, go repair specific names: \"\" (empty string), ... (R’s ellipsis “dots” construct), ..j j number. basically treated like \"\", always repaired.Example unique-ified names:augmented definition unique specific motivation: ensures element can identified name, least protected backtick quotes. Literally, work:practical significance variable names inside data frame, many workflows rely indexing name. Note uniqueness refers implicitly vector names.Let’s explore edge cases: single dot followed number, .j, need repair.Two dots followed number, ..j, need repair. goes three dots, ..., ellipsis “dots” construct. can’t function names, even quoted backticks, repaired.repaired \"\".","code":"original unique-ified\n      \"\"         ...1\n       x        x...2\n      \"\"         ...3\n     ...         ...4\n       y            y\n       x        x...6\ndf[[\"name\"]]\ndf$`name`\nwith(df, `name`)\nsubset(df, select = `name`)\ndplyr::select(df, `name`)\ndf <- tibble(`.1` = \"ok\")\ndf$`.1`\n#> [1] \"ok\"\nsubset(df, select = `.1`)\n#> # A tibble: 1 × 1\n#>   `.1` \n#>   <chr>\n#> 1 ok\ndplyr::select(df, `.1`)\n#> # A tibble: 1 × 1\n#>   `.1` \n#>   <chr>\n#> 1 ok\ndf <- tibble(`..1` = \"not ok\")\n#> Error:\n#> ! Column 1 must not have names of the form ... or ..j.\n#> Use .name_repair to specify repair.\n#> Caused by error in `repaired_names()`:\n#> ! Names can't be of the form `...` or `..j`.\n#> ✖ These names are invalid:\n#>   * \"..1\" at location 1.\nwith(df, `..1`)\n#> Error in eval(substitute(expr), data, enclos = parent.frame()): ..1 used in an incorrect context, no ... to look in\ndplyr::select(df, `..1`)\n#> Error in dplyr::select(df, ..1): '...' used in an incorrect context\n\ndf <- tibble(`...` = \"not ok\")\n#> Error:\n#> ! Column 1 must not have names of the form ... or ..j.\n#> Use .name_repair to specify repair.\n#> Caused by error in `repaired_names()`:\n#> ! Names can't be of the form `...` or `..j`.\n#> ✖ These names are invalid:\n#>   * \"...\" at location 1.\nsubset(df, select = `...`)\n#> Error in eval(expr, envir, enclos): '...' used in an incorrect context\ndplyr::select(df, `...`)\n#> Error in eval(expr, envir, enclos): '...' used in an incorrect context"},{"path":"names-attribute.html","id":"making-names-unique","chapter":"3 Names attribute","heading":"3.5.1 Making names unique","text":"many ways make names unique. append suffix form ...j name duplicate \"\" ..., j position. ?absolute position j helpful numbering within elements\nshare name. Context: troubleshooting data import lots columns\ndysfunctional names.hypothesize ’s better “level playing field” repairing\nnames, .e. foo appears twice, instances get repaired, just \nsecond occurrence.unique level naminess regarded normative tibble user must expressly request tibble names violate (possible).Base R’s function make.unique(). revisit example , comparing tidyverse strategy making names unique vs. make.unique() .","code":"Original Unique names     Result of\n   names  (tidyverse) make.unique()\n      \"\"         ...1            \"\"\n       x        x...2             x\n      \"\"         ...3            .1\n     ...         ...4           ...\n       y            y             y\n       x        x...6           x.1"},{"path":"names-attribute.html","id":"roundtrips","chapter":"3 Names attribute","heading":"3.5.2 Roundtrips","text":"unique-ifying names, assume input names repaired strategy, .e. consuming dogfood. Therefore, pre-existing suffixes form ...j stripped, prior (re-)constructing suffixes. interacts poorly names, need take control name repair.Example re-unique-ified names:JB: conceivable control argument, e.g. dogfood = TRUE, (currently unexported) function ","code":" original unique-ified\n     ...5         ...1\n        x        x...2\n    x...3        x...3\n       \"\"         ...4\nx...1...5        x...5"},{"path":"names-attribute.html","id":"when-is-minimal-better-than-unique","chapter":"3 Names attribute","heading":"3.5.3 When is minimal better than unique?","text":"ever want import tibble enforce minimal names, instead unique? Sometimes first row data source – allegedly variable names – actually contains data resulting tibble reshaped , e.g., tidyr::gather(). case, better munge names import. common special case “data stored names” phenomenon.general, may want tolerate minimal names dysfunctional names just awkward phase object passing definitive solution applied downstream.","code":""},{"path":"names-attribute.html","id":"ugly-with-a-purpose","chapter":"3 Names attribute","heading":"3.5.4 Ugly, with a purpose","text":"might say names like x...5 ugly right. ’re calling feature, bug! Names automatically unique-ified tidyverse catch eye give user strong encouragement take charge situation.","code":""},{"path":"names-attribute.html","id":"why-so-many-dots","chapter":"3 Names attribute","heading":"3.5.5 Why so many dots?","text":"suffix ...j, 3 leading dots, result jointly satisfying multiple requirements. important anticipate missing name, suffix becomes entire name. elected make suffix syntactic name (), non-syntactic names frequent cause unexpected friction users. means suffix can’t j, .j, ..j, non-syntactic. must ...j.","code":""},{"path":"names-attribute.html","id":"why-dots-in-the-first-place","chapter":"3 Names attribute","heading":"3.5.6 Why dot(s) in the first place?","text":"underscore _ also considered choosing suffix strategy, rejected. ? syntactic names can’t start underscore want suffix syntactic. Also, dot . already used base R’s make.names() replace invalid characters. seems simpler , therefore, better use character, way, much possible name repair. use dot ., put front, many times necessary.","code":""},{"path":"names-attribute.html","id":"universal-names","chapter":"3 Names attribute","heading":"3.6 Universal names","text":"Universal names unique, sense described , syntactic, normal R sense. Universal names appealing play nicely base R tidyverse functions accept unquoted variable names.","code":""},{"path":"names-attribute.html","id":"syntactic-names","chapter":"3 Names attribute","heading":"3.6.1 Syntactic names","text":"syntactic name R:Consists letters, numbers, dot . underscore _ characters.Starts letter starts dot . followed anything \nnumber.reserved word, function TRUE...., R’s special ellipsis “dots” construct.form ..j, j number.See R’s documentation Reserved words Quotes, specifically section names identifiers.syntactic name can used “” code. example, require quoting order work non-standard evaluation, list indexing via $, formula, packages like dplyr ggplot2.Note syntactic property individual name.","code":"\n## a syntactic name doesn't require quoting\nx <- tibble::tibble(.else = \"else?!\")\nx$.else\n#> [1] \"else?!\"\ndplyr::select(x, .else)\n#> # A tibble: 1 × 1\n#>   .else \n#>   <chr> \n#> 1 else?!\n## use a non-syntactic name\nx <- tibble::tibble(`else` = \"else?!\")\n\n## this code does not parse\n# x$else\n# dplyr::select(x, else)\n\n## a non-syntacitic name requires quoting\nx$`else`\n#> [1] \"else?!\"\ndplyr::select(x, `else`)\n#> # A tibble: 1 × 1\n#>   `else`\n#>   <chr> \n#> 1 else?!"},{"path":"names-attribute.html","id":"making-an-individual-name-syntactic","chapter":"3 Names attribute","heading":"3.6.2 Making an individual name syntactic","text":"many ways fix non-syntactic name. ’s logic compares base::make.names() single name:: Definition syntactically valid.\nClaim: syn_name name made syntactic, \nsyn_name == make.names(syn_name). find counterexample, tell us!\nClaim: syn_name name made syntactic, \nsyn_name == make.names(syn_name). find counterexample, tell us!: invalid character replaced dot ..Different: always fix name prepending dot .. base::make.names()\nsometimes prefixes X times appends dot ..\nmeans turn ... .... ..j ...j, j \nnumber. base::make.names() modify ... ..j, \nregarded bug (?).\nmeans turn ... .... ..j ...j, j \nnumber. base::make.names() modify ... ..j, \nregarded bug (?).Different: treat NA \"\" : become .. \nfirst make names minimal. base::make.names() turns NA \"NA.\" \"\" \"X\".Examples tidyverse approach making individual names syntactic versus base::make.names():Currently implemented unexported function tibble:::make_syntactic().","code":"Original Syntactic name    Result of\n    name    (tidyverse) make.names()\n      \"\"              .            X\n      NA              .          NA.\n     (y)            .y.         X.y.\n      _z            ._z          X_z\n    .2fa          ..2fa        X.2fa\n   FALSE         .FALSE       FALSE.\n     ...           ....          ...\n     ..3           ...3          ..3"},{"path":"names-attribute.html","id":"why-universal","chapter":"3 Names attribute","heading":"3.6.3 Why universal?","text":"Now can state motivation universal names, group-wise property unique element-wise property syntactic.practice, want syntactic names, probably also want unique. need order refer individual elements easily, without ambiguity without quoting.Universal names can requested tidyverse via .name_repair = \"universal\", functions expose name repair.","code":""},{"path":"names-attribute.html","id":"making-names-universal","chapter":"3 Names attribute","heading":"3.6.4 Making names universal","text":"Universal names implemented variation unique names. Basically, suffixes stripped ... replaced \"\". draft names transformed tibble:::make_syntactic() (step omitted unique names). ...j suffixes appended necessary.Note suffix stripping substitution \"\" ... happens draft names made syntactic. , although tibble:::make_syntactic turns ... ...., universal unique name repair turn ... something form ...j.","code":""},{"path":"names-attribute.html","id":"messaging-user-about-name-repair","chapter":"3 Names attribute","heading":"3.7 Messaging user about name repair","text":"Name repair communicated user. ’s tibble messages:","code":"\nx <- tibble::tibble(\n  x = 1, x = 2, `a1:` = 3, `_x_y}` = 4,\n  .name_repair = \"universal\"\n)\n#> New names:\n#> • `x` -> `x...1`\n#> • `x` -> `x...2`\n#> • `a1:` -> `a1.`\n#> • `_x_y}` -> `._x_y.`"},{"path":"call-data-details.html","id":"call-data-details","chapter":"4 Name details arguments","heading":"4 Name details arguments","text":"","code":""},{"path":"call-data-details.html","id":"what-are-data-and-details-arguments","chapter":"4 Name details arguments","heading":"4.1 What are data and details arguments?","text":"arguments function typically fall two broad sets: one set supplies data compute , supplies arguments control details computation. example:log(), data x, detail base logarithm.log(), data x, detail base logarithm.mean(), data x, details much data trim\nends (trim) handle missing values (na.rm).mean(), data x, details much data trim\nends (trim) handle missing values (na.rm).t.test(), data x y, details test \nspecified alternative, mu, paired, var.equal, conf.level\narguments.t.test(), data x y, details test \nspecified alternative, mu, paired, var.equal, conf.level\narguments.Typically, data arguments don’t default values, work vectors data frames, details arguments defaults, take single values (like TRUE FALSE, single string specifies method).","code":""},{"path":"call-data-details.html","id":"whats-the-pattern","chapter":"4 Name details arguments","heading":"4.2 What’s the pattern?","text":"calling function, data arguments come first, specified position, followed details arguments specified name.Never use partial matching, allows refer argument unique prefix, e.g. mean(x, n = TRUE). Partial matching useful early days R quick dirty interactive analysis save little time shortening argument names. However, today, R editing environments support autocomplete partial matching saves single keystroke, makes code substantially harder read.can make R give warning ’re using partially named argument special option. Call usethis::use_partial_warnings() make default R sessions.","code":"\ny <- c(1:10, NA)\n# Good\nmean(y, na.rm = TRUE)\n#> [1] 5.5\n\n# Bad\nmean(x = y, , TRUE)\n#> [1] 5.5\nmean(, TRUE, x = y)\n#> [1] 5.5\noptions(warnPartialMatchArgs = TRUE)\nmean(x = 1:10, n = FALSE)\n#> Warning in mean.default(x = 1:10, n = FALSE): partial argument match of 'n' to\n#> 'na.rm'\n#> [1] 5.5"},{"path":"call-data-details.html","id":"why-is-this-useful","chapter":"4 Name details arguments","heading":"4.3 Why is this useful?","text":"think ’s reasonable assume reader knows function know data arguments (order), repeating names just takes space without aiding communication. leads naturally %>% don’t specify name first argument either (since comes left-hand side %>%.)However, don’t think ’s reasonable expect people remember order details arguments. example, don’t think people know second argument mean() trim, even though mean() extremely commonly used function. Spelling names ","code":""},{"path":"call-data-details.html","id":"what-are-the-exceptions","chapter":"4 Name details arguments","heading":"4.4 What are the exceptions?","text":"think main exception rule teaching function first time. makes sense emphasis names data arguments help people understand exactly ’s going . example, R data science introduce ggplot2 write code like:end chapter, assume reader familiar basic structure rest book uses style recommended :","code":"\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + \n  geom_point()\nggplot(mpg, aes(displ, hwy)) + \n  geom_point()"},{"path":"function-names.html","id":"function-names","chapter":"5 Function names","heading":"5 Function names","text":"Follow style guide (.e. use snake_cake).","code":""},{"path":"function-names.html","id":"nouns-vs-verbs","chapter":"5 Function names","heading":"5.1 Nouns vs verbs","text":"general, prefer verbs. Use imperative mood: mutate() mutated(), mutates(), mutating(); () (), (), (), hide() hid(), hides(), hiding().Exception: noun-y interfaces ’re building complex object like ggplot2 recipes (verb-y interface ggvis mistake).Nouns singular (geom_point() geom_points()), simply plurisation rules English complex.","code":""},{"path":"function-names.html","id":"function-families","chapter":"5 Function names","heading":"5.2 Function families","text":"Use prefixes group functions together based common input common purpose. Prefixes better suffixes auto-complete. Examples: ggplot2, purrr. Counter example: shiny.sure common prefixes package. Works well stringr (esp. stringi), forcats, xml2, rvest. ’s limited number short prefixes think break every package .Use suffixes variations theme (e.g. map_int(), map_lgl(), map_dbl(); str_locate(), str_locate_all().)Strive thematic unity related functions. Can make related fuctions rhyme? number letters? similar background (.e. Germanic origins vs. French).","code":""},{"path":"function-names.html","id":"length","chapter":"5 Function names","heading":"5.3 Length","text":"Err side long rather short (reading generally important writing). Autocomplete mostly take care nuisance can always shorten later come better name. (hard make long later, may take good word lot work reclaim later).Length name inversely proportional frequency usage. Reserve short words functions likely used frequently.","code":""},{"path":"function-names.html","id":"conflicts","chapter":"5 Function names","heading":"5.4 Conflicts","text":"can’t expect avoid conflicts every existing CRAN package, strive avoid conflicts “nearby” packages (.e. packages commonly used package).","code":""},{"path":"function-names.html","id":"techniques","chapter":"5 Function names","heading":"5.5 Techniques","text":"ThesaurusList common verbsRhyming dictionary","code":""},{"path":"function-names.html","id":"other-good-advice","chapter":"5 Function names","heading":"5.6 Other good advice","text":"Shall Call .. SomethingManagerThe Poetry Function Naming","code":""},{"path":"args-hidden.html","id":"args-hidden","chapter":"6 Avoid hidden arguments","heading":"6 Avoid hidden arguments","text":"","code":""},{"path":"args-hidden.html","id":"whats-the-problem","chapter":"6 Avoid hidden arguments","heading":"6.1 What’s the problem?","text":"Functions easier understand results depend values inputs. function returns surprisingly different results inputs, say hidden arguments. Hidden arguments make code harder reason , correctly predict output also need know state.Related:pattern surprising inputs; Spooky action \nsuprising outputs.","code":""},{"path":"args-hidden.html","id":"what-are-some-examples","chapter":"6 Avoid hidden arguments","heading":"6.2 What are some examples?","text":"One common source hidden arguments use global options. can useful control display , discussed Chapter 16), affect computation:result data.frame(x = \"\")$x depends value global\nstringsAsFactors option: ’s TRUE (default) get factor;\n’s false, get character vector.result data.frame(x = \"\")$x depends value global\nstringsAsFactors option: ’s TRUE (default) get factor;\n’s false, get character vector.lm()’s handling missing values depends global option \nna.action. default na.omit drops missing values\nprior fitting model (inconvenient results\npredict() don’t line input data. modelr::na.warn()\nprovides approach line base behaviours: drops\nmissing values warning.)lm()’s handling missing values depends global option \nna.action. default na.omit drops missing values\nprior fitting model (inconvenient results\npredict() don’t line input data. modelr::na.warn()\nprovides approach line base behaviours: drops\nmissing values warning.)Another common source hidden inputs system locale:strptime() relies names weekdays months current\nlocale. means strptime(\"1 Jan 2020\", \"%d %b %Y\") work \ncomputers English locale, fail elsewhere. particularly\ntroublesome Europeans frequently colleagues speak \ndifferent language.strptime() relies names weekdays months current\nlocale. means strptime(\"1 Jan 2020\", \"%d %b %Y\") work \ncomputers English locale, fail elsewhere. particularly\ntroublesome Europeans frequently colleagues speak \ndifferent language..POSIXct() depends current timezone. following code returns\ndifferent underlying times run different computers:\n\n.POSIXct(\"2020-01-01 09:00\")\n#> [1] \"2020-01-01 09:00:00 UTC\".POSIXct() depends current timezone. following code returns\ndifferent underlying times run different computers:toupper() tolower() depend current locale. faily\nuncommon cause problems languages either\nuse character set, use rules capitalisation \nEnglish. However, behaviour cause bug ggplot2 \ninternally takes geom = \"identity\" turns GeomIdentity\nfind object actually computation. Turkish, however, \nupper case version İ, Geomİdentity exist. \nmeant time ggplot2 work Turkish computers.\n\nlibrary(stringr)\n\nstr_to_upper(\"\")\n#> [1] \"\"\nstr_to_upper(\"\", locale = \"tr\")\n#> [1] \"İ\"toupper() tolower() depend current locale. faily\nuncommon cause problems languages either\nuse character set, use rules capitalisation \nEnglish. However, behaviour cause bug ggplot2 \ninternally takes geom = \"identity\" turns GeomIdentity\nfind object actually computation. Turkish, however, \nupper case version İ, Geomİdentity exist. \nmeant time ggplot2 work Turkish computers.similar reasons, sort() order() rely lexicographic\norder defined current locale. factor() uses order(), \nresults factor depend implicitly current locale. (\nimaginary problem \nquestion) attests).similar reasons, sort() order() rely lexicographic\norder defined current locale. factor() uses order(), \nresults factor depend implicitly current locale. (\nimaginary problem \nquestion) attests).functions depend external settings, surprising way:Sys.time() depends system time, ’s surprise: getting\ncurrent time whole point function!Sys.time() depends system time, ’s surprise: getting\ncurrent time whole point function!read.csv(path) depends value path contents \nfile location. Reading file system necessarily implies \nresults depend contents file, path, \nsurprise.read.csv(path) depends value path contents \nfile location. Reading file system necessarily implies \nresults depend contents file, path, \nsurprise.Random number generators like runif() peek value special\nglobal variable .Random.seed. little surprising, \ndidn’t global state every call runif() return \nvalue.Random number generators like runif() peek value special\nglobal variable .Random.seed. little surprising, \ndidn’t global state every call runif() return \nvalue.","code":"\nas.POSIXct(\"2020-01-01 09:00\")\n#> [1] \"2020-01-01 09:00:00 UTC\"\nlibrary(stringr)\n\nstr_to_upper(\"i\")\n#> [1] \"I\"\nstr_to_upper(\"i\", locale = \"tr\")\n#> [1] \"İ\""},{"path":"args-hidden.html","id":"why-is-it-important","chapter":"6 Avoid hidden arguments","heading":"6.3 Why is it important?","text":"Hidden arguments bad make much harder predict output fuction. worst offender far stringsAsFactors option changes number functions (including data.frame(), .data.frame(), read.csv()) treat character vectors. exists mostly historical reasons, described stringsAsFactors: unauthorized biography Roger Peng stringsAsFactors = <sigh>\nThomas Lumley. )Allowing system locale affect result function subtle source bugs sharing code people work different countries. clear, defaults rarely cause problems languages share writing system share () collation rules. main exceptions tend European languages varying rules modified letters, e.g. Norwegian, å comes end alphabet. However, cause problems take long time track : ’re unlikely expect coefficients linear model different2 code run different country!","code":""},{"path":"args-hidden.html","id":"how-can-i-remediate-the-problem","chapter":"6 Avoid hidden arguments","heading":"6.4 How can I remediate the problem?","text":"Generally, hidden arguments easy avoid creating new functions: simply avoid depending environment variables (like locale), global options (like stringsAsFactors). easiest way problems creep realise function hidden inputs; make sure consult list common offenders provided .must depend environment variable option, make sure ’s explicit argument, Chapter 16. arguments generally affect computation (side-effects like printed output status messages); affect results, follow Chapter 15 make sure inform user ’s happening.existing function hidden input, ’ll need take steps . First make sure input explicit option, make sure ’s printed. example, lets take .POSIXct() basically looks something like :tz argument present, ’s obvious \"\" means take system timezone. Let’s first make explicit:important argument coming (indirectly) environment variable, also print user hasn’t explicitly set :","code":"\nas.POSIXct <- function(x, tz = \"\") {\n  base::as.POSIXct(x, tz = tz)\n}\nas.POSIXct(\"2020-01-01 09:00\")\n#> [1] \"2020-01-01 09:00:00 UTC\"\nas.POSIXct <- function(x, tz = Sys.timezone()) {\n  base::as.POSIXct(x, tz = tz)\n}\nas.POSIXct(\"2020-01-01 09:00\")\n#> [1] \"2020-01-01 09:00:00 UTC\"\nas.POSIXct <- function(x, tz = Sys.timezone()) {\n  if (missing(tz)) {\n    message(\"Using `tz = '\", tz, \"'`\")\n  }\n  base::as.POSIXct(x, tz = tz)\n}\nas.POSIXct(\"2020-01-01 09:00\")\n#> Using `tz = 'UTC'`\n#> [1] \"2020-01-01 09:00:00 UTC\""},{"path":"args-data-details.html","id":"args-data-details","chapter":"7 Data, descriptors, details","heading":"7 Data, descriptors, details","text":"","code":""},{"path":"args-data-details.html","id":"whats-the-pattern-1","chapter":"7 Data, descriptors, details","heading":"7.1 What’s the pattern?","text":"Function arguments always come order: data, descriptors, details.Data arguments provide core data. required, usually\nvectors often determine type size output. Data arguments\noften called data, x, y.Data arguments provide core data. required, usually\nvectors often determine type size output. Data arguments\noften called data, x, y.Descriptor arguments describe essential details operation, \nusually required.Descriptor arguments describe essential details operation, \nusually required.Details arguments control details function. arguments\noptional (default values), typically scalars\n(e.g. na.rm = TRUE, n = 10, prop = 0.1).Details arguments control details function. arguments\noptional (default values), typically scalars\n(e.g. na.rm = TRUE, n = 10, prop = 0.1).standard argument order makes easier understand function glance, order implies required arguments always come optional arguments.Related patterns:... can play role data argument (.e. \narbitrary number inputs), paste(). pattern best using\nsparingly, described detail Chapter 19.... can play role data argument (.e. \narbitrary number inputs), paste(). pattern best using\nsparingly, described detail Chapter 19.... can also used capture details arguments pass \nfunctions. See Chapters 18 21\nuse ... safely possible situation.... can also used capture details arguments pass \nfunctions. See Chapters 18 21\nuse ... safely possible situation.descriptor default value, think inform user\n, Chapter 15.descriptor default value, think inform user\n, Chapter 15.","code":""},{"path":"args-data-details.html","id":"what-are-some-examples-1","chapter":"7 Data, descriptors, details","heading":"7.2 What are some examples?","text":"mean() one data argument (x) two details (trim na.rm).mean() one data argument (x) two details (trim na.rm).mathematical (+, -, *, /, …) comparison (<, >, ==,\n…) operators two data arguments.mathematical (+, -, *, /, …) comparison (<, >, ==,\n…) operators two data arguments.ifelse() three data arguments (test, yes, ).ifelse() three data arguments (test, yes, ).merge() two data arguments (x, y), one descriptor (),\nnumber details (, .dups, sort, …).merge() two data arguments (x, y), one descriptor (),\nnumber details (, .dups, sort, …).rnorm() data arguments three descriptors (n, mean, sd).\nmean sd default 0 1 respectively, makes feel\nlike details. ’d argue shouldn’t defaults make \nclear ’re descriptors. side-effect \nmaking rnrorm() consistent RNGs.\nrt(n, df, ncp), however, think ncp default 0 make\nclear non-centrality parameter detail t-distribution,\ncore part.rnorm() data arguments three descriptors (n, mean, sd).\nmean sd default 0 1 respectively, makes feel\nlike details. ’d argue shouldn’t defaults make \nclear ’re descriptors. side-effect \nmaking rnrorm() consistent RNGs.rt(n, df, ncp), however, think ncp default 0 make\nclear non-centrality parameter detail t-distribution,\ncore part.grepl() one data argument (x), one descriptor (pattern), \nnumber details (fixed, perl, ignore.case, …).grepl() one data argument (x), one descriptor (pattern), \nnumber details (fixed, perl, ignore.case, …).stringr::str_detect() one data argument (string), one descriptor\n(pattern), one detail argument (negate).stringr::str_detect() one data argument (string), one descriptor\n(pattern), one detail argument (negate).stringr::str_sub() three data arguments (string, start, \nend). might wonder makes start end data arguments, \nadmit took figure , think \ncrucial factor can give single string multiple\nstart/end positions:\n\nstringr::str_sub(\"Hello\", 1:5, -1)\n#> [1] \"Hello\" \"ello\"  \"llo\"   \"lo\"    \"o\"\nwrite str_sub() today, ’d call first argument x, \nwouldn’t give start end default values.stringr::str_sub() three data arguments (string, start, \nend). might wonder makes start end data arguments, \nadmit took figure , think \ncrucial factor can give single string multiple\nstart/end positions:write str_sub() today, ’d call first argument x, \nwouldn’t give start end default values.ggplot2::ggplot() one data argument (data) one descriptor\n(mapping).ggplot2::ggplot() one data argument (data) one descriptor\n(mapping).lm() one data argument (data), one descriptor (formula), \nmany details (weights, na.action, method, …). Unfortunately\nformula comes data. historical accident, \nputting model variables data frame relatively recent\ninnovation long life cycle lm().lm() one data argument (data), one descriptor (formula), \nmany details (weights, na.action, method, …). Unfortunately\nformula comes data. historical accident, \nputting model variables data frame relatively recent\ninnovation long life cycle lm().purrr::map() one data argument (.x) one descriptor (.f).\npurrr::map2() two data arguments (.x, .y) one descrptor\n(.f).purrr::map() one data argument (.x) one descriptor (.f).\npurrr::map2() two data arguments (.x, .y) one descrptor\n(.f).mapply() number data arguments (…), one descriptor (FUN),\nnumber details (SIMPLIFY, USE.NAMES, …). descriptor\ncomes data arguments.mapply() number data arguments (…), one descriptor (FUN),\nnumber details (SIMPLIFY, USE.NAMES, …). descriptor\ncomes data arguments.first glance looks like ggplot2 layer functions, like\ngeom_point(), don’t obey principle first argument \nmapping (descriptor) second data (presumably data\nargument). However, ggplot2 doesn’t use pipe. \n(like ggplot1), first\nargument plot modify, data object case,\noutput also plot. data acts descriptor, \nmodifies behaviour layer.\nargument order differs layers ggplot(), \ncommonly specify data plot, aesthetic mappings\nlayers. little confusing, think time shown \nreasonable design decision.first glance looks like ggplot2 layer functions, like\ngeom_point(), don’t obey principle first argument \nmapping (descriptor) second data (presumably data\nargument). However, ggplot2 doesn’t use pipe. \n(like ggplot1), first\nargument plot modify, data object case,\noutput also plot. data acts descriptor, \nmodifies behaviour layer.argument order differs layers ggplot(), \ncommonly specify data plot, aesthetic mappings\nlayers. little confusing, think time shown \nreasonable design decision.","code":"\nstringr::str_sub(\"Hello\", 1:5, -1)\n#> [1] \"Hello\" \"ello\"  \"llo\"   \"lo\"    \"o\""},{"path":"args-data-details.html","id":"why-is-it-important-1","chapter":"7 Data, descriptors, details","heading":"7.3 Why is it important?","text":"convention makes easy understand structure function glance: important arguments always left hand side, ’s obvious arguments affect shape output. Strongly connecting shape first argument shape output makes dplyr (data frames), stringr (character vectors), map family (vectors) easier learn. families functions represent transformations preserve shape modifying value. combined pipe, leads code focusses transformations, objects transformed.argument types also affect call function. discussed Chapter 4, never name data arguments, always name details arguments. convention balances concision readability.","code":""},{"path":"args-data-details.html","id":"how-do-i-avoid-the-problem","chapter":"7 Data, descriptors, details","heading":"7.4 How do I avoid the problem?","text":"avoid problem, carefully analyse arguments ensure correctly categorise argument. ’s generally easy tell difference data argument details argument, particularly data arguments required details arguments optional. can harder distinguish data descriptor, descriptor details. partly categorisation false trichotomy: ’s really continuous gradient absolutely required totally optional discrete steps. Nevertheless, think three categories useful, even don’t get absolutely right every time, framework help better average.couple heuristics can also check :arguments generally ordered important least important?\nimportant argument comes unimportant argument, may \nassigned argument wrong category. (Note ordering isn’t\nstrict: sometimes ’s important organise related arguments together\nprecisely order importance.)arguments generally ordered important least important?\nimportant argument comes unimportant argument, may \nassigned argument wrong category. (Note ordering isn’t\nstrict: sometimes ’s important organise related arguments together\nprecisely order importance.)arguments defaults come arguments without defaults?\nmay sign argument order wrong, ’ve\nassigned default value required argument (See Chapter\n@ref(#def-required) details.)arguments defaults come arguments without defaults?\nmay sign argument order wrong, ’ve\nassigned default value required argument (See Chapter\n@ref(#def-required) details.)","code":""},{"path":"args-data-details.html","id":"how-do-i-remediate-past-mistakes","chapter":"7 Data, descriptors, details","heading":"7.5 How do I remediate past mistakes?","text":"Generally, possible fix exported function preserving old behaviour new behaviour. Typically, need perform major surgery function arguments, convey different conventions arguments named. implies deprecate entire existing function replace new alternative. invasive user, ’s best sparingly: mistake minor, ’re better waiting ’ve collected problems fixing .Take tidyr::gather(), example. number problems design made hard use. Relevant chapter, argument order wrong.","code":""},{"path":"args-independence.html","id":"args-independence","chapter":"8 Avoid dependencies between arguments","heading":"8 Avoid dependencies between arguments","text":"","code":""},{"path":"args-independence.html","id":"whats-the-problem-1","chapter":"8 Avoid dependencies between arguments","heading":"8.1 What’s the problem?","text":"Avoid creating dependencies details arguments certain combinations permitted. Dependencies arguments makes functions harder use remember arguments interact, reading call, need read multiple arguments interpreting one.","code":""},{"path":"args-independence.html","id":"what-are-some-examples-2","chapter":"8 Avoid dependencies between arguments","heading":"8.2 What are some examples?","text":"rep() can supply times unless times \nvector:\n\nrep(1:3, times = 2, = 3)\n#>  [1] 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3\nrep(1:3, times = 1:3, = 2)\n#> Error rep(1:3, times = 1:3, = 2): invalid 'times' argument\nLearn Chapter 11.rep() can supply times unless times \nvector:Learn Chapter 11.var(), na.rm used use set. supply \nuse na.rm, na.rm silently ignored.var(), na.rm used use set. supply \nuse na.rm, na.rm silently ignored.rgamma() can provide either scale rate. supply \nget error warning:\n\nrgamma(5, shape = 1, rate = 2, scale = 1/2)\n#> Warning rgamma(5, shape = 1, rate = 2, scale = 1/2): specify 'rate' \n#> 'scale' \n#> [1] 0.06124463 0.27777043 1.81029217 0.19422776 0.28172955\nrgamma(5, shape = 1, rate = 2, scale = 2)\n#> Error rgamma(5, shape = 1, rate = 2, scale = 2): specify 'rate' 'scale' bothIn rgamma() can provide either scale rate. supply \nget error warning:grepl() perl, fixed, ignore.case arguments can\neither TRUE FALSE. fixed = TRUE overrides perl = TRUE,\nignore.case works fixed = FALSE. fixed perl\nchange another argument, pattern, interpreted.grepl() perl, fixed, ignore.case arguments can\neither TRUE FALSE. fixed = TRUE overrides perl = TRUE,\nignore.case works fixed = FALSE. fixed perl\nchange another argument, pattern, interpreted.library() character.argument changes package \nintepreted:\n\nggplot2 <- \"dplyr\"\n\n# Loads ggplot2\nlibrary(ggplot2)\n\n# Loads dplyr\nlibrary(ggplot2, character.= TRUE)library() character.argument changes package \nintepreted:forcats::fct_lump() decides algorithm use based \ncombination n prop arguments.forcats::fct_lump() decides algorithm use based \ncombination n prop arguments.ggplot2::geom_histogram(), can specify histogram breaks \nthree ways: number bins, width bin (binwidth,\nplus center boundary), exact breaks. can pick\none three options, hard convey documentation.\n’s also implied precedence one option \nsupplied, one silently win.ggplot2::geom_histogram(), can specify histogram breaks \nthree ways: number bins, width bin (binwidth,\nplus center boundary), exact breaks. can pick\none three options, hard convey documentation.\n’s also implied precedence one option \nsupplied, one silently win.readr::locale() ’s complex dependency decimal_mark\ngrouping_mark can’t value, US \nEurope use different standards.readr::locale() ’s complex dependency decimal_mark\ngrouping_mark can’t value, US \nEurope use different standards.See Sections 10.3.1 10.3.2 two exceptions dependency via specific patterns missing arguments.","code":"\nrep(1:3, times = 2, each = 3)\n#>  [1] 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3\nrep(1:3, times = 1:3, each = 2)\n#> Error in rep(1:3, times = 1:3, each = 2): invalid 'times' argument\nrgamma(5, shape = 1, rate = 2, scale = 1/2)\n#> Warning in rgamma(5, shape = 1, rate = 2, scale = 1/2): specify 'rate' or\n#> 'scale' but not both\n#> [1] 0.06124463 0.27777043 1.81029217 0.19422776 0.28172955\nrgamma(5, shape = 1, rate = 2, scale = 2)\n#> Error in rgamma(5, shape = 1, rate = 2, scale = 2): specify 'rate' or 'scale' but not both\nggplot2 <- \"dplyr\"\n\n# Loads ggplot2\nlibrary(ggplot2)\n\n# Loads dplyr\nlibrary(ggplot2, character.only = TRUE)"},{"path":"args-independence.html","id":"why-is-this-important","chapter":"8 Avoid dependencies between arguments","heading":"8.3 Why is this important?","text":"complicated interdependencies arguments major downsides:suggests many viable code paths really\n(unnecessary) possibilities still occupy head space.\nmemorise set allowed combinations, rather \nimplied structure function.suggests many viable code paths really\n(unnecessary) possibilities still occupy head space.\nmemorise set allowed combinations, rather \nimplied structure function.increases implementation complexity. Interdependence arguments\nsuggests complex implementation paths harder analyse \ntest.increases implementation complexity. Interdependence arguments\nsuggests complex implementation paths harder analyse \ntest.makes documentation harder write. use extra words \nexplain exactly combinations arguments work together, ’s \nobvious words go. ’s interaction \narg_a arg_b document arg_a, arg_b, \n?makes documentation harder write. use extra words \nexplain exactly combinations arguments work together, ’s \nobvious words go. ’s interaction \narg_a arg_b document arg_a, arg_b, \n?","code":""},{"path":"args-independence.html","id":"how-do-i-remediate","chapter":"8 Avoid dependencies between arguments","heading":"8.4 How do I remediate?","text":"Often problems arise scope function grows time. function initially designed, scope small, grew incrementally time. point seem worth additional effort refactor new design, now large complex function. makes problem hard avoid.remediate problem, ’ll need think holistically reconsider complete interface. two common outcomes illustrated case studies :Splitting function multiple functions one thing.Splitting function multiple functions one thing.Encapulsating related details arguments single object.Encapulsating related details arguments single object.See also larger case study Chapter 11 problem tangled problems.changes interface occur exported functions package, ’ll need consider preserve interface deprecation warnings. important functions, worth generating message includes new code copy paste.","code":""},{"path":"args-independence.html","id":"cs-fct-lump","chapter":"8 Avoid dependencies between arguments","heading":"8.4.1 Case study: fct_lump()","text":"many different ways decide lump uncommon factor levels together, initially attempted encode arguments fct_lump(). However, time number arguments increased, gets harder harder tell options . Currently three behaviours:n prop missing - merge together least\nfrequent levels, ensuring still smallest level.\n(case, ties.method argument ignored.)n prop missing - merge together least\nfrequent levels, ensuring still smallest level.\n(case, ties.method argument ignored.)n supplied: positive, preserves n common values.n supplied: positive, preserves n common values.prop supplied: positive, preservesOnly prop supplied: positive, preservesBoth n prop supplied: due bug code, treated\nway n prop missing! (really \nerror)n prop supplied: due bug code, treated\nway n prop missing! (really \nerror)better break three functions:fct_lump_n(f, n)fct_lump_prop(f, prop)fct_lump_smallest(f)three advantages:name function helps remind purpose.name function helps remind purpose.’s way supply n prop.’s way supply n prop.ties.method argument appear fct_lump_n() _prop(),\n_smallest().ties.method argument appear fct_lump_n() _prop(),\n_smallest().","code":""},{"path":"args-independence.html","id":"case-study-grepl-vs-stringrstr_detect","chapter":"8 Avoid dependencies between arguments","heading":"8.4.2 Case study: grepl() vs stringr::str_detect()","text":"grepl(), three arguments take either FALSE TRUE: ignore.case, perl, fixed, might suggest 2 ^ 3 = 16 possible invocations. However, number combinations allowed:Part problem resolved making clear one important choice matching engine use: POSIX 1003.2 extended regular expressions (default), Perl-style regular expressions (perl = TRUE) fixed matching (fixed = TRUE). better approach use pattern Chapter 12, create new argument called something like engine = c(\"POSIX\", \"perl\", \"fixed\").problem ignore.case can affect two three engines: POSIX perl. hard remedy without creating completely new matching engine. Anything case always harder might expect different languages different rules.stringr takes different approach, encoding engine attribute pattern:advantage engine can take different arguments.alternative approach separate engine argument:approach bit discoverable (’s clearly another argument affects pattern), ’s slightly less general, boundary() engine, doesn’t match patterns boundaries:also mean argument engine, affected another argument, pattern, interpreted, repeat problem slightly different form.’s appealing details match wrapped single object.","code":"\nx <- grepl(\"a\", letters, fixed = TRUE, ignore.case = TRUE)\n#> Warning in grepl(\"a\", letters, fixed = TRUE, ignore.case = TRUE): argument\n#> 'ignore.case = TRUE' will be ignored\nx <- grepl(\"a\", letters, fixed = TRUE, perl = TRUE)\n#> Warning in grepl(\"a\", letters, fixed = TRUE, perl = TRUE): argument 'perl =\n#> TRUE' will be ignored\nlibrary(stringr)\n\nx <- str_detect(letters, \"a\")\n# short for:\nx <- str_detect(letters, regex(\"a\"))\nx <- str_detect(letters, fixed(\"a\"))\nx <- str_detect(letters, coll(\"a\"))\nx <- str_detect(letters, \"a\", engine = regex())\nx <- str_detect(letters, \"a\", engine = fixed())\nx <- str_detect(letters, \"a\", engine = coll())\nx <- str_detect(letters, boundary(\"word\"))\n# Seems confusing: now you can omit the pattern argument?\nx <- str_detect(letters, engine = boundary(\"word\"))"},{"path":"case-study-setnames.html","id":"case-study-setnames","chapter":"9 Case study: setNames()","heading":"9 Case study: setNames()","text":"","code":""},{"path":"case-study-setnames.html","id":"what-does-setnames-do","chapter":"9 Case study: setNames()","heading":"9.1 What does setNames() do?","text":"stats::setNames() shorthand allows set vector names inline (’s little surprising lives stats package). simple definition:easy use:function short (just two lines code!) yields surprisingly rich analysis.","code":"\nsetNames <- function(object = nm, nm) {\n  names(object) <- nm\n  object\n}\n# Instead of\nx <- 1:3\nnames(x) <- c(\"a\", \"b\", \"c\")\n\n# Can write\nx <- setNames(1:3, c(\"a\", \"b\", \"c\"))\nx\n#> a b c \n#> 1 2 3"},{"path":"case-study-setnames.html","id":"how-can-we-improve-the-names","chapter":"9 Case study: setNames()","heading":"9.2 How can we improve the names?","text":"Firstly, prefer snake_case camelCase, ’d call function set_names(). need consider arguments:think first argument, object, better called x order\nemphasise function works vectors (\nvectors names).think first argument, object, better called x order\nemphasise function works vectors (\nvectors names).second argument, nm rather terse, don’t see disadvantage\ncalling names. think also argue \ncalled y since meaning obvious function name.second argument, nm rather terse, don’t see disadvantage\ncalling names. think also argue \ncalled y since meaning obvious function name.yields:","code":"\nset_names <- function(x = names, names) {\n  names(x) <- names\n  x\n}"},{"path":"case-study-setnames.html","id":"what-about-the-default-values","chapter":"9 Case study: setNames()","heading":"9.3 What about the default values?","text":"default values setNames() little hard understand, default value first argument second argument. defined way make possible name character vector :decision leads function signature violates one principles Chapter 7: required argument comes optional argument. Fortunately, can fix easily still preserve useful ability name vector :helps emphasise x primary argument.","code":"\nsetNames(nm = c(\"apple\", \"banana\", \"cake\"))\n#>    apple   banana     cake \n#>  \"apple\" \"banana\"   \"cake\"\nset_names <- function(x, names = x) {\n  names(x) <- names\n  x\n}\n\nset_names(c(\"apple\", \"banana\", \"cake\"))\n#>    apple   banana     cake \n#>  \"apple\" \"banana\"   \"cake\""},{"path":"case-study-setnames.html","id":"what-about-bad-inputs","chapter":"9 Case study: setNames()","heading":"9.4 What about bad inputs?","text":"Now ’ve considered function works correct inputs, ’s time consider work malformed inputs. current function checks neither length type:can resolve asserting names always character vector, length x:also frame test using vctrs assertions:Note slipped assertion x vector. slightly improves error message accidentally supply wrong sort input set_names():Note ’re simply checking length names , rather recycling , .e. invariant vec_size(set_names(x, y)) vec_size(x), vec_size_common(x, y). think correct behaviour usually add names vector create lookup table, lookup table useful duplicated names. makes set_names() less general return better error messages something suspicious (can always use explicit rep_along() want behaviour.)","code":"\nset_names(1:3, \"a\")\n#>    a <NA> <NA> \n#>    1    2    3\n\nset_names(1:3, list(letters[1:3], letters[4], letters[5:6]))\n#> c(\"a\", \"b\", \"c\")                d      c(\"e\", \"f\") \n#>                1                2                3\nset_names <- function(x, names = x) {\n  if (!is.character(names) || length(names) != length(x)) {\n    stop(\"`names` must be a character vector the same length as `x`.\", call. = FALSE)\n  }\n  \n  names(x) <- names\n  x\n}\n\nset_names(1:3, \"a\")\n#> Error: `names` must be a character vector the same length as `x`.\nset_names(1:3, list(letters[1:3], letters[4], letters[5:6]))\n#> Error: `names` must be a character vector the same length as `x`.\nlibrary(vctrs)\n\nset_names <- function(x, names = x) {\n  vec_assert(x)\n  vec_assert(names, ptype = character(), size = length(x))\n\n  names(x) <- names\n  x\n}\nsetNames(mean, 1:3)\n#> Error in names(object) <- nm: names() applied to a non-vector\nset_names(mean, 1:3)\n#> Error in `set_names()`:\n#> ! `x` must be a vector, not a function."},{"path":"case-study-setnames.html","id":"how-could-we-extend-this-function","chapter":"9 Case study: setNames()","heading":"9.5 How could we extend this function?","text":"Now ’ve modified function doesn’t violate principles book, can think might extend . Currently function useful setting names constant. Maybe extend also make easier change existing names? One way allow names function:also support anonymous function formula shortcut used many places tidyverse.Now set_names() supports overriding modifying names. removing ? turns setNames() supported , stricter checks prohibit:can fix another clause:However, think muddied logic. resolve , think pull checking code separate function. trying approaches, ended :replaces vec_assert() set_names(). separate input checking implementation blank line help visually group parts function.simplify function even , think bad idea becaues mingles input validation implementation:","code":"\nset_names <- function(x, names = x) {\n  vec_assert(x)\n  \n  if (is.function(names)) {\n    names <- names(base::names(x))\n  }\n  vec_assert(names, ptype = character(), size = length(x))\n\n  names(x) <- names\n  x\n}\n\nx <- c(a = 1, b = 2, c = 3)\nset_names(x, toupper)\n#> A B C \n#> 1 2 3\nset_names <- function(x, names = x) {\n  vec_assert(x)\n  \n  if (is.function(names) || rlang::is_formula(names)) {\n    fun <- rlang::as_function(names)\n    names <- fun(base::names(x))\n  }\n  vec_assert(names, ptype = character(), size = length(x))\n\n  names(x) <- names\n  x\n}\n\nx <- c(a = 1, b = 2, c = 3)\nset_names(x, ~ paste0(\"x-\", .))\n#> x-a x-b x-c \n#>   1   2   3\nx <- c(a = 1, b = 2, c = 3)\nsetNames(x, NULL)\n#> [1] 1 2 3\nset_names(x, NULL)\n#> Error in `set_names()`:\n#> ! `names` must be a vector, not `NULL`.\nset_names <- function(x, names = x) {\n  vec_assert(x)\n  \n  if (!is.null(names)) {\n    if (is.function(names) || rlang::is_formula(names)) {\n      fun <- rlang::as_function(names)\n      names <- fun(base::names(x))\n    }\n    \n  }\n\n  names(x) <- names\n  x\n}\n\nx <- c(a = 1, b = 2, c = 3)\nset_names(x, NULL)\n#> [1] 1 2 3\ncheck_names <- function(names, x) {\n  if (is.null(names)) {\n    names\n  } else if (vec_is(names)) {\n    vec_assert(names, ptype = character(), size = length(x))  \n  } else if (is.function(names)) {\n    check_names_2(names(base::names(x)), x)\n  } else if (rlang::is.formula(names)) {\n    check_names_2(rlang::as_function(names), x)\n  } else {\n    rlang::abort(\"`names` must be NULL, a function or formula, or a vector\")\n  }\n}\nset_names <- function(x, names = x) {\n  vec_assert(x)\n  names <- check_names(names, x)\n  \n  names(x) <- names\n  x\n}\n# Don't do this\nset_names <- function(x, names = x) {\n  vec_assert(x)\n  names(x) <- check_names(names, x)\n  x\n}\n\n# Or even\nset_names <- function(x, names = x) {\n  `names<-`(vec_assert(x), check_names(names, x))\n}"},{"path":"case-study-setnames.html","id":"compared-to-rlangset_names","chapter":"9 Case study: setNames()","heading":"9.6 Compared to rlang::set_names()","text":"’re familiar rlang, might notice ’ve ended something rather similar rlang::set_names(). However, careful analysis chapter lead differences. rlang::set_names():Calls second argument nm, instead something descriptive.\nthink simply never sat fully considered \ninterface.Calls second argument nm, instead something descriptive.\nthink simply never sat fully considered \ninterface.Coerces nm character vector. allows rlang::set_names(1:4) \nautomatically name vector, seems relatively weak new feature\nreturn cost throwing error message provide \nunsual vector type. (lists data frames .character() methods\nwork basically type vector, even completely\ninappropriate.)Coerces nm character vector. allows rlang::set_names(1:4) \nautomatically name vector, seems relatively weak new feature\nreturn cost throwing error message provide \nunsual vector type. (lists data frames .character() methods\nwork basically type vector, even completely\ninappropriate.)Passes ... function nm. now think decision \nmistake: substantially complicates interface return \nrelatively small investment.Passes ... function nm. now think decision \nmistake: substantially complicates interface return \nrelatively small investment.","code":""},{"path":"def-required.html","id":"def-required","chapter":"10 Required args shouldn’t have defaults","heading":"10 Required args shouldn’t have defaults","text":"","code":""},{"path":"def-required.html","id":"whats-the-problem-2","chapter":"10 Required args shouldn’t have defaults","heading":"10.1 What’s the problem?","text":"absence default value imply argument required; presence default imply argument optional.reading function, ’s important able tell glance arguments must supplied optional. Otherwise need rely user carefully read documentation.","code":""},{"path":"def-required.html","id":"what-are-some-examples-3","chapter":"10 Required args shouldn’t have defaults","heading":"10.2 What are some examples?","text":"sample() neither x size default value, suggesting \nrequired, function error didn’t supply .\nsize optional, determined complex conditional.\n\nsample(1:4)\n#> [1] 4 2 1 3\nsample(4)\n#> [1] 1 4 2 3In sample() neither x size default value, suggesting \nrequired, function error didn’t supply .\nsize optional, determined complex conditional.rt() (draw random numbers t-distribution) looks like \nrequires ncp parameter doesn’t.rt() (draw random numbers t-distribution) looks like \nrequires ncp parameter doesn’t.download.file() looks like requires method argument \nactually consults global option (download.file.method) ’s \nsupplied.download.file() looks like requires method argument \nactually consults global option (download.file.method) ’s \nsupplied.lm() defaults formula, data, subset, weights,\nna.action, offset. formula actually required, even\nabsence fails generate clear error message:\n\nlm()\n#> Error terms.formula(formula, data = data): argument valid modellm() defaults formula, data, subset, weights,\nna.action, offset. formula actually required, even\nabsence fails generate clear error message:help() vignette() default first argument,\nsuggesting ’re required. ’re : calling help() \nvignette() without arguments lists help topics vignettes\nrespectively.help() vignette() default first argument,\nsuggesting ’re required. ’re : calling help() \nvignette() without arguments lists help topics vignettes\nrespectively.diag(), argument x default 1, ’s required: \ndon’t supply get error:\n\ndiag()\n#> Error diag(): argument \"nrow\" missing, default\ndiag(x = 1)\n#>      [,1]\n#> [1,]    1\nConversely, nrow ncol don’t defaults aren’t required.diag(), argument x default 1, ’s required: \ndon’t supply get error:Conversely, nrow ncol don’t defaults aren’t required.ggplot2::geom_abline(), slope intercept don’t defaults\nrequired. don’t supply default slope = 1\nintercept = 0, taken aes() ’re provided\n.ggplot2::geom_abline(), slope intercept don’t defaults\nrequired. don’t supply default slope = 1\nintercept = 0, taken aes() ’re provided\n.common warning sign use missing() inside function.","code":"\nsample(1:4)\n#> [1] 4 2 1 3\nsample(4)\n#> [1] 1 4 2 3\nlm()\n#> Error in terms.formula(formula, data = data): argument is not a valid model\ndiag()\n#> Error in diag(): argument \"nrow\" is missing, with no default\ndiag(x = 1)\n#>      [,1]\n#> [1,]    1"},{"path":"def-required.html","id":"what-are-the-exceptions-1","chapter":"10 Required args shouldn’t have defaults","heading":"10.3 What are the exceptions?","text":"two exceptions rule:pair arguments provide alternative specification \nunderlying concept. ever possible supply one argument.pair arguments provide alternative specification \nunderlying concept. ever possible supply one argument.can either supply one complex object, handful simpler\nobjects.can either supply one complex object, handful simpler\nobjects.cases, believe benefits outweigh costs violating standard pattern.","code":""},{"path":"def-required.html","id":"args-mutually-exclusive","chapter":"10 Required args shouldn’t have defaults","heading":"10.3.1 Pair of mututally exclusive arguments","text":"number functions allow supply exactly one two possible arguments:read.table() allows supply data either path file,\ninline text.read.table() allows supply data either path file,\ninline text.rvest::html_node() allows select HTML nodes either css\nselector xpath expression.rvest::html_node() allows select HTML nodes either css\nselector xpath expression.forcats::fct_other() allows either keep drop specified\nfactor values.forcats::fct_other() allows either keep drop specified\nfactor values.modelr::seq_range() allows create sequence range x \neither specifying length sequence (n) distance\nvalues ().modelr::seq_range() allows create sequence range x \neither specifying length sequence (n) distance\nvalues ().use technique, use xor() missing() check exactly one argument supplied:documentation, make clear one pair can supplied:technique used exactly two possible arguments. two , generally sign create functions. See case studies Chapter 11 Section 8.4.1 examples.","code":"\nif (!xor(missing(keep), missing(drop))) {\n  stop(\"Must supply exactly one of `keep` and `drop`\", call. = FALSE)\n}\n#' @param keep,drop Pick one of `keep` and `drop`:\n#'   * `keep` will preserve listed levels, replacing all others with \n#'     `other_level`.\n#'   * `drop` will replace listed levels with `other_level`, keeping all\n#'     as is."},{"path":"def-required.html","id":"args-compound","chapter":"10 Required args shouldn’t have defaults","heading":"10.3.2 One compound argument vs multiple simple arguments","text":"related, less generally useful, form allow user supply either single complex argument several smaller arguments. example:stringr::str_sub(x, cbind(start, end)) equivalent \nstr_sub(x, start, end).stringr::str_sub(x, cbind(start, end)) equivalent \nstr_sub(x, start, end).stringr::str_replace_all(x, c(pattern = replacement)) equivalent \nstringr(x, pattern, replacement).stringr::str_replace_all(x, c(pattern = replacement)) equivalent \nstringr(x, pattern, replacement).rgb(cbind(r, g, b)) equivalent rgb(r, g, b) (See Chapter\n17 details).rgb(cbind(r, g, b)) equivalent rgb(r, g, b) (See Chapter\n17 details).options(list(= 1, b = 2)) equivalent options(= 1, b = 2).options(list(= 1, b = 2)) equivalent options(= 1, b = 2).compelling reason provide sort interface another function might return complex output want use input. example, seems reasonable able feed output str_locate() directly str_sub():equally, weird provide matrix subsetting known positions:str_sub() allows either individual vectors supplied start end, two-colummn matrix supplied start.implement functions, branch type first argument:(? branch arguments missing? combination?)make clear documentation:","code":"\nlibrary(stringr)\n\nx <- c(\"aaaaab\", \"aaab\", \"ccccb\")\nloc <- str_locate(x, \"a+b\")\n\nstr_sub(x, loc)\n#> [1] \"aaaaab\" \"aaab\"   NA\nstr_sub(\"Hadley\", cbind(2, 4))\n#> [1] \"adl\"\nstr_sub <- function(string, start = 1L, end = -1L) {\n  if (is.matrix(start)) {\n    if (!missing(end)) {\n      stop(\"`end` must be missing when `start` is a matrix\", call. = FALSE)\n    }\n    if (ncol(start) != 2) {\n      stop(\"Matrix `start` must have exactly two columns\", call. = FALSE)\n    }\n    stri_sub(string, from = start[, 1], to = start[, 2])\n  } else {\n    stri_sub(string, from = start, to = end)\n  }\n}\n#' @param start,end Integer vectors giving the `start` (default: first)\n#'   and `end` (default: last) positions, inclusively. Alternatively, you\n#'   pass a two-column matrix to `start`, i.e. `str_sub(x, start, end)`\n#'   is equivalent to `str_sub(x, cbind(start, end))`"},{"path":"cs-rep.html","id":"cs-rep","chapter":"11 Case study: rep()","heading":"11 Case study: rep()","text":"","code":""},{"path":"cs-rep.html","id":"what-does-rep-do","chapter":"11 Case study: rep()","heading":"11.1 What does rep() do?","text":"rep() extremely useful base R function repeats vector x various ways. three details arguments: times, , length.out3 interact complicated ways. Let’s explore basics first:times length.replicate vector way, length.allows specify non-integer number replications. specify , length.wins.argument repeats individual components vector rather whole vector:can combine times:supply vector times works similar way , repeating component specified number times:","code":"\nx <- c(1, 2, 4)\n\nrep(x, times = 3)\n#> [1] 1 2 4 1 2 4 1 2 4\nrep(x, length.out = 10)\n#>  [1] 1 2 4 1 2 4 1 2 4 1\nrep(x, times = 3, length.out = 10)\n#>  [1] 1 2 4 1 2 4 1 2 4 1\nrep(x, each = 3)\n#> [1] 1 1 1 2 2 2 4 4 4\nrep(x, each = 3, times = 2)\n#>  [1] 1 1 1 2 2 2 4 4 4 1 1 1 2 2 2 4 4 4\nrep(x, times = x)\n#> [1] 1 2 2 4 4 4 4"},{"path":"cs-rep.html","id":"what-makes-this-function-hard-to-understand","chapter":"11 Case study: rep()","heading":"11.2 What makes this function hard to understand?","text":"’s complicated dependency times, length., .\ntimes length.control underlying variable \ndifferent ways, can set simultaneously. times \nmostly independent, specify vector times can’t use\n.\n\nrep(1:3, times = c(2, 2, 2), = 2)\n#> Error rep(1:3, times = c(2, 2, 2), = 2): invalid 'times' argumentThere’s complicated dependency times, length., .\ntimes length.control underlying variable \ndifferent ways, can set simultaneously. times \nmostly independent, specify vector times can’t use\n.think using times vector confusing switches \nreplicating whole vector replicating individual values vector,\nlike usually .\n\nrep(1:3, = 2)\n#> [1] 1 1 2 2 3 3\nrep(1:3, times = 2)\n#> [1] 1 2 3 1 2 3\nrep(1:3, times = c(2, 2, 2))\n#> [1] 1 1 2 2 3 3I think using times vector confusing switches \nreplicating whole vector replicating individual values vector,\nlike usually .think two problems underlying cause: rep() trying much single function. think can make things simpler turning rep() two functions: one replicates full vector, one replicates element vector.","code":"\nrep(1:3, times = c(2, 2, 2), each = 2)\n#> Error in rep(1:3, times = c(2, 2, 2), each = 2): invalid 'times' argument\nrep(1:3, each = 2)\n#> [1] 1 1 2 2 3 3\nrep(1:3, times = 2)\n#> [1] 1 2 3 1 2 3\nrep(1:3, times = c(2, 2, 2))\n#> [1] 1 1 2 2 3 3"},{"path":"cs-rep.html","id":"how-might-we-improve-the-situation","chapter":"11 Case study: rep()","heading":"11.3 How might we improve the situation?","text":"Two create two new functions, need first come names: like rep_each() rep_full(). rep_each() fairly easy name come . rep_full() little harder took iterations: like full number letters , makes two functions look like belong together.Next, need think arguments. single data argument: x, vector replicate. rep_each() single details argument specifies number times replicate element. rep_time() two mutually exclusive details arguments, number times repeat whole vector, desired length output.call arguments? ’ve already captured different replication strategies (vs. full) function name, think argument specifies number times replicate can , times seems reasonable. second argument rep_full(), draw inspiration rep() uses length.. think ’s obvious argument controls output, length adequate.implementation rep_full() rep_each() terms rep.int() rep_len() suggests R-core members aware problem.(Note downside using length argument name: call base::length() avoid evaluating missing length times supplied.)One downside approach want replicate component entire vector, use two function calls, much verbose rep() equivalent. However, don’t think terribly common use case, think longer call readable.said, one argument single rep function rep_each() rep_full() return result change order (.e. ’re commutative):","code":"\nrep_each <- function(x, times) {\n  times <- rep(times, length.out = length(x))\n  rep(x, times = times)\n}\n\nrep_full <- function(x, times, length) {\n  if (!xor(missing(times), missing(length))) {\n    stop(\"Must supply exactly one of `times` and `length`\", call. = FALSE)\n  } \n  \n  if (!missing(times)) {\n    length <- times * base::length(x)\n  }\n  \n  rep(x, length.out = length)\n}\nx <- c(1, 2, 4)\n\nrep_each(x, times = 2)\n#> [1] 1 1 2 2 4 4\nrep_full(x, times = 2)\n#> [1] 1 2 4 1 2 4\n\nrep_each(x, times = x)\n#> [1] 1 2 2 4 4 4 4\n\nrep_full(x, length = 5)\n#> [1] 1 2 4 1 2\nrep_full(rep_each(x, times = 2), times = 3)\n#>  [1] 1 1 2 2 4 4 1 1 2 2 4 4 1 1 2 2 4 4\nrep_each(rep_full(x, times = 3), times = 2) \n#>  [1] 1 1 2 2 4 4 1 1 2 2 4 4 1 1 2 2 4 4"},{"path":"cs-rep.html","id":"dealing-with-bad-inputs","chapter":"11 Case study: rep()","heading":"11.4 Dealing with bad inputs","text":"implementations work well correct inputs, also work without error number incorrect inputs:code , used vec_assert() vec_recycle() make desired types, sizes, recycling rules explicit.","code":"\nrep_full(1:3, 1:3)\n#> Warning in rep(x, length.out = length): first element used of 'length.out'\n#> argument\n#> [1] 1 2 3\nlibrary(vctrs)\n\nrep_each <- function(x, times) {\n  vec_assert(times, numeric())\n  times <- vec_recycle(times, vec_size(x))\n  \n  rep.int(x, times)\n}\n\nrep_full <- function(x, times, length) {\n  if (!xor(missing(times), missing(length))) {\n    stop(\"Must supply exactly one of `times` and `length`\", call. = FALSE)\n  } else if (!missing(times)) {\n    vec_assert(times, numeric(), 1L)\n    length <- times * base::length(x)\n  } else if (!missing(length)) {\n    vec_assert(length, numeric(), 1L)\n  }\n  \n  rep_len(x, length)\n}\nrep_full(1:3, \"x\")\n#> Error in `rep_full()`:\n#> ! `times` must be a vector with type <double>.\n#> Instead, it has type <character>.\nrep_full(1:3, c(1, 2))\n#> Error in `rep_full()`:\n#> ! `times` must have size 1, not size 2."},{"path":"def-enum.html","id":"def-enum","chapter":"12 Enumerate possible options","heading":"12 Enumerate possible options","text":"","code":""},{"path":"def-enum.html","id":"whats-the-pattern-2","chapter":"12 Enumerate possible options","heading":"12.1 What’s the pattern?","text":"possible values argument small set strings, set default argument set possible values, use match.arg() rlang::arg_match() function body. convention advertises user possible values, makes easy generate informative error message inappropriate inputs.","code":""},{"path":"def-enum.html","id":"what-are-some-examples-4","chapter":"12 Enumerate possible options","heading":"12.2 What are some examples?","text":"difftime(), units can one “auto”, “secs”, “mins”,\n“hours”, “days”, “weeks”.difftime(), units can one “auto”, “secs”, “mins”,\n“hours”, “days”, “weeks”.format(), justify can “left”, “right”, “center”, “none”.format(), justify can “left”, “right”, “center”, “none”.trimws(), can choose side remove whitespace :\n“”, “left”, “right”.trimws(), can choose side remove whitespace :\n“”, “left”, “right”.rank(), can select ties.method one “average”,\n“first”, “last”, “random”, “max”, “min”.rank(), can select ties.method one “average”,\n“first”, “last”, “random”, “max”, “min”.RSiteSearch(), can restrict results “functions”,\n“vignettes”, “views”, combination three.RSiteSearch(), can restrict results “functions”,\n“vignettes”, “views”, combination three.","code":""},{"path":"def-enum.html","id":"why-is-it-important-2","chapter":"12 Enumerate possible options","heading":"12.3 Why is it important?","text":"convention makes possible advertise possible set values argument. advertisement happens function specification, see tooltips autocomplete, without look documentation.","code":""},{"path":"def-enum.html","id":"how-do-i-use-it","chapter":"12 Enumerate possible options","heading":"12.4 How do I use it?","text":"use technique, set default value character vector, first value default. Inside function, use match.arg() rlang::arg_match() checks value comes known good set. interface pattern often coupled implementation uses switch().Take rank(), example. heart implementation looks like :Note match.arg() automatically throw error value set:also supports partial matching following code shorthand `ties.method = “random”:generally believe partial matching bad idea, makes code harder read. rlang::arg_match() alternative match.args() doesn’t support partial matching. Instead provides helpful error message:","code":"\nrank <- function(x, \n                 ties.method = \n                  c(\"average\", \"first\", \"last\", \"random\", \"max\", \"min\")\n                 ) {\n  \n  ties.method <- match.arg(ties.method)\n  \n  switch(ties.method, \n    average = , \n    min = , \n    max = .Internal(rank(x, length(x), ties.method)), \n    first = sort.list(sort.list(x)),\n    last = sort.list(rev.default(sort.list(x, decreasing = TRUE))), \n    random = sort.list(order(x, stats::runif(length(x))))\n  )\n}\n\nx <- c(1, 2, 2, 3, 3, 3)\n\nrank(x)\n#> [1] 1.0 2.5 2.5 5.0 5.0 5.0\nrank(x, ties.method = \"first\")\n#> [1] 1 2 3 4 5 6\nrank(x, ties.method = \"min\")\n#> [1] 1 2 2 4 4 4\nrank(x, ties.method = \"middle\")\n#> Error in match.arg(ties.method): 'arg' should be one of \"average\", \"first\", \"last\", \"random\", \"max\", \"min\"\nrank(x, ties.method = \"r\")\n#> [1] 1 2 3 4 5 6\nrank2 <- function(x, \n                 ties.method = \n                  c(\"average\", \"first\", \"last\", \"random\", \"max\", \"min\")\n                 ) {\n  \n  ties.method <- rlang::arg_match(ties.method)\n  rank(x, ties.method = ties.method)\n}\n\nrank2(x, ties.method = \"r\")\n#> Error in `rank2()`:\n#> ! `ties.method` must be one of \"average\", \"first\", \"last\", \"random\",\n#>   \"max\", or \"min\", not \"r\".\n#> ℹ Did you mean \"random\"?"},{"path":"def-enum.html","id":"how-keep-defaults-short","chapter":"12 Enumerate possible options","heading":"12.4.1 How keep defaults short?","text":"technique best used set possible values short. can see ’s already getting unwieldy rank(). long list possibilities, two options use Chapter 14. Unfortunately approaches major downsides:Set single default supply possible values match.arg():\n\nrank2 <- function(x, ties.method = \"average\") {\n  ties.method <- match.arg(\n    ties.method, \n    c(\"average\", \"first\", \"last\", \"random\", \"max\", \"min\")\n  )\n}\ndownside approach can longer see values\npermitted, ’d describe separately \ndocumentation. can, however, still see default value \nfunction speci.Set single default supply possible values match.arg():downside approach can longer see values\npermitted, ’d describe separately \ndocumentation. can, however, still see default value \nfunction speci.Store options exported function, use defaults:\n\nties_method <- function() {\n  c(\"average\", \"first\", \"last\", \"random\", \"max\", \"min\")\n}\n\nrank2 <- function(x, ties.method = ties_method()) {\n  ties.method <- match.arg(ties.method)\n}\ndownside approach looking function spec,\ncan longer easily see default value, set possible\nvalues. However, possible values can easily found programmatically.\nworthwhile want share permitted values across\nmultiple functions. example stats::p.adjust(),\nstats::pairwise.prop.test(), stats::pairwise.t.test(),\nstats::pairwise.wilcox.test() use\np.adjust.method = p.adjust.methods.Store options exported function, use defaults:downside approach looking function spec,\ncan longer easily see default value, set possible\nvalues. However, possible values can easily found programmatically.worthwhile want share permitted values across\nmultiple functions. example stats::p.adjust(),\nstats::pairwise.prop.test(), stats::pairwise.t.test(),\nstats::pairwise.wilcox.test() use\np.adjust.method = p.adjust.methods.","code":"\nrank2 <- function(x, ties.method = \"average\") {\n  ties.method <- match.arg(\n    ties.method, \n    c(\"average\", \"first\", \"last\", \"random\", \"max\", \"min\")\n  )\n}\nties_method <- function() {\n  c(\"average\", \"first\", \"last\", \"random\", \"max\", \"min\")\n}\n\nrank2 <- function(x, ties.method = ties_method()) {\n  ties.method <- match.arg(ties.method)\n}"},{"path":"def-magical.html","id":"def-magical","chapter":"13 Avoid magical defaults","heading":"13 Avoid magical defaults","text":"","code":""},{"path":"def-magical.html","id":"whats-the-problem-3","chapter":"13 Avoid magical defaults","heading":"13.1 What’s the problem?","text":"function behaves differently default value supplied explicitly, say magical default. Magical defaults best avoided make harder interpret function specification.","code":""},{"path":"def-magical.html","id":"what-are-some-examples-5","chapter":"13 Avoid magical defaults","heading":"13.2 What are some examples?","text":"data.frame(), default argument row.names NULL, \nsupply directly get different result:\n\nfun_call(data.frame)\n#> base::data.frame(..., row.names = NULL, check.rows = FALSE, check.names = TRUE, \n#>     fix.empty.names = TRUE, stringsAsFactors = FALSE)\n\nx <- setNames(nm = letters[1:3])\ndata.frame(x)\n#>   x\n#> \n#> b b\n#> c c\ndata.frame(x, row.names = NULL)\n#>   x\n#> 1 \n#> 2 b\n#> 3 cIn data.frame(), default argument row.names NULL, \nsupply directly get different result:hist(), default value xlim range(breaks), \ndefault value breaks \"Sturges\". range(\"Sturges\") returns\nc(\"Sturges\", \"Sturges\") doesn’t work supplied explicitly:\n\nfun_call(hist.default)\n#> graphics::hist.default(x, breaks = \"Sturges\", freq = NULL, probability = !freq, \n#>     include.lowest = TRUE, right = TRUE, fuzz = 1e-07, density = NULL, \n#>     angle = 45, col = \"lightgray\", border = NULL, main = paste(\"Histogram \", \n#>         xname), xlim = range(breaks), ylim = NULL, xlab = xname, \n#>     ylab, axes = TRUE, plot = TRUE, labels = FALSE, nclass = NULL, \n#>     warn.unused = TRUE, ...)\n\nhist(1:10, xlim = c(\"Sturges\", \"Sturges\"))\n#> Error plot.window(xlim, ylim, \"\", ...): invalid 'xlim' valueIn hist(), default value xlim range(breaks), \ndefault value breaks \"Sturges\". range(\"Sturges\") returns\nc(\"Sturges\", \"Sturges\") doesn’t work supplied explicitly:Vectorize(), default argument vectorize.args arg.names,\nvariable defined inside Vectorize(), supply \nexplicitly get error.\n\nfun_call(Vectorize)\n#> base::Vectorize(FUN, vectorize.args = arg.names, SIMPLIFY = TRUE, \n#>     USE.NAMES = TRUE)\n\nVectorize(rep.int, vectorize.args = arg.names)\n#> Error Vectorize(rep.int, vectorize.args = arg.names): object 'arg.names' foundIn Vectorize(), default argument vectorize.args arg.names,\nvariable defined inside Vectorize(), supply \nexplicitly get error.rbeta(), default value ncp 0, explicitly supply\nfunction uses different algorithm:\n\nrbeta\n#> function (n, shape1, shape2, ncp = 0) \n#> {\n#>     (missing(ncp)) \n#>         .Call(C_rbeta, n, shape1, shape2)\n#>     else {\n#>         X <- rchisq(n, 2 * shape1, ncp = ncp)\n#>         X/(X + rchisq(n, 2 * shape2))\n#>     }\n#> }\n#> <bytecode: 0x55f37b5aa310>\n#> <environment: namespace:stats>rbeta(), default value ncp 0, explicitly supply\nfunction uses different algorithm:table(), default value dnn list.names(...); \nlist.names() defined inside table().table(), default value dnn list.names(...); \nlist.names() defined inside table().readr::read_csv() progress = show_progress(), version\n1.3.1, show_progress() exported package. means \nattempted run , ’d see error message:\n\nshow_progress()\n#> Error show_progress(): find function \"show_progress\"readr::read_csv() progress = show_progress(), version\n1.3.1, show_progress() exported package. means \nattempted run , ’d see error message:usethis::use_rmarkdown_template(), template_dir default value\ntolower(asciify(template_name)), asciify exported. \nmeans ’s way interactively explore default value.usethis::use_rmarkdown_template(), template_dir default value\ntolower(asciify(template_name)), asciify exported. \nmeans ’s way interactively explore default value.","code":"\nfun_call(data.frame)\n#> base::data.frame(..., row.names = NULL, check.rows = FALSE, check.names = TRUE, \n#>     fix.empty.names = TRUE, stringsAsFactors = FALSE)\n\nx <- setNames(nm = letters[1:3])\ndata.frame(x)\n#>   x\n#> a a\n#> b b\n#> c c\ndata.frame(x, row.names = NULL)\n#>   x\n#> 1 a\n#> 2 b\n#> 3 c\nfun_call(hist.default)\n#> graphics::hist.default(x, breaks = \"Sturges\", freq = NULL, probability = !freq, \n#>     include.lowest = TRUE, right = TRUE, fuzz = 1e-07, density = NULL, \n#>     angle = 45, col = \"lightgray\", border = NULL, main = paste(\"Histogram of\", \n#>         xname), xlim = range(breaks), ylim = NULL, xlab = xname, \n#>     ylab, axes = TRUE, plot = TRUE, labels = FALSE, nclass = NULL, \n#>     warn.unused = TRUE, ...)\n\nhist(1:10, xlim = c(\"Sturges\", \"Sturges\"))\n#> Error in plot.window(xlim, ylim, \"\", ...): invalid 'xlim' value\nfun_call(Vectorize)\n#> base::Vectorize(FUN, vectorize.args = arg.names, SIMPLIFY = TRUE, \n#>     USE.NAMES = TRUE)\n\nVectorize(rep.int, vectorize.args = arg.names)\n#> Error in Vectorize(rep.int, vectorize.args = arg.names): object 'arg.names' not found\nrbeta\n#> function (n, shape1, shape2, ncp = 0) \n#> {\n#>     if (missing(ncp)) \n#>         .Call(C_rbeta, n, shape1, shape2)\n#>     else {\n#>         X <- rchisq(n, 2 * shape1, ncp = ncp)\n#>         X/(X + rchisq(n, 2 * shape2))\n#>     }\n#> }\n#> <bytecode: 0x55f37b5aa310>\n#> <environment: namespace:stats>\nshow_progress()\n#> Error in show_progress(): could not find function \"show_progress\""},{"path":"def-magical.html","id":"what-are-the-exceptions-2","chapter":"13 Avoid magical defaults","heading":"13.3 What are the exceptions?","text":"’s ok use behaviour want default value one argument another. example, take rlang::set_names(), allows create named vector two inputs:default value names vector . provides convenient shortcut naming vector :can see technique merge(), .x .y default value , factor() labels defaults value levels.use technique, make sure never use value argument comes later argument list. example, file.copy() overwrite defaults value recursive, recursive argument defined overwrite:makes defaults arguments harder understand can’t just read left--right.","code":"\nfun_call(set_names)\n#> rlang::set_names(x, nm = x, ...)\n\nset_names(1:3, letters[1:3])\n#> a b c \n#> 1 2 3\nset_names(letters[1:3])\n#>   a   b   c \n#> \"a\" \"b\" \"c\"\nfun_call(file.copy)\n#> base::file.copy(from, to, overwrite = recursive, recursive = FALSE, \n#>     copy.mode = TRUE, copy.date = FALSE)"},{"path":"def-magical.html","id":"what-causes-the-problem","chapter":"13 Avoid magical defaults","heading":"13.4 What causes the problem?","text":"three primary causes:Overuse lazy evaluation default values, evaluated \nenvironment function, described \nAdvanced R.\n’s simple example:\n\nf1 <- function(x = y) {\n  y <- trunc(Sys.time(), units = \"months\")\n  x\n}\n\ny <- 1\nf1()\n#> [1] \"2022-11-01 UTC\"\nf1(y)\n#> [1] 1\nx takes value y default, ’s evaluated inside \nfunction, yielding 1. y supplied explicitly, evaluated\ncaller environment, yielding 2.Overuse lazy evaluation default values, evaluated \nenvironment function, described \nAdvanced R.\n’s simple example:x takes value y default, ’s evaluated inside \nfunction, yielding 1. y supplied explicitly, evaluated\ncaller environment, yielding 2.Use missing() default value never consulted:\n\nf2 <- function(x = 1) {\n  (missing(x)) {\n    2\n  } else {\n    x\n  }\n}\n\nf2()\n#> [1] 2\nf2(1)\n#> [1] 1Use missing() default value never consulted:packages, ’s easy use non-exported function without thinking\n. function available , package author, \nuser package, makes harder understand\npackage works.packages, ’s easy use non-exported function without thinking\n. function available , package author, \nuser package, makes harder understand\npackage works.","code":"\nf1 <- function(x = y) {\n  y <- trunc(Sys.time(), units = \"months\")\n  x\n}\n\ny <- 1\nf1()\n#> [1] \"2022-11-01 UTC\"\nf1(y)\n#> [1] 1\nf2 <- function(x = 1) {\n  if (missing(x)) {\n    2\n  } else {\n    x\n  }\n}\n\nf2()\n#> [1] 2\nf2(1)\n#> [1] 1"},{"path":"def-magical.html","id":"how-do-i-remediate-the-problem","chapter":"13 Avoid magical defaults","heading":"13.5 How do I remediate the problem?","text":"problem generally easy avoid new functions:Don’t use default values depend variables defined inside function.Don’t use default values depend variables defined inside function.Don’t use missing()4.Don’t use missing()4.Don’t use unexported functions.Don’t use unexported functions.made mistake older function can remediate using NULL default, described Chapter 14. problem caused unexported function, can also choose document export .modification break existing code, expands function interface: previous code continue work, function also work argument passed NULL input (probably didn’t previously).functions like data.frame() NULL already permissible value, ’ll need use sentinel object, described Section 14.4.3.","code":"\n`%||%` <- function(x, y) if (is.null(x)) y else x\n\nf1_better <- function(x = NULL) {\n  y <- trunc(Sys.time(), units = \"weeks\")\n  x <- x %||% y\n  \n  x\n}\n\nf2_better <- function(x = NULL) {\n  x <- x %||% 2\n  \n  x\n}\nsentinel <- function() structure(list(), class = \"sentinel\")\nis_sentinel <- function(x) inherits(x, \"sentinel\")\n\ndata.frame_better <- function(..., row.names = sentinel()) {\n  if (is_sentinel(row.names)) {\n    # old default behaviour\n  }\n}"},{"path":"def-short.html","id":"def-short","chapter":"14 Keep defaults short and sweet","heading":"14 Keep defaults short and sweet","text":"","code":""},{"path":"def-short.html","id":"whats-the-pattern-3","chapter":"14 Keep defaults short and sweet","heading":"14.1 What’s the pattern?","text":"Default values short sweet. makes function specification easier scan.","code":""},{"path":"def-short.html","id":"what-are-some-examples-6","chapter":"14 Keep defaults short and sweet","heading":"14.2 What are some examples?","text":"following examples, drawn base R, illustrate functions don’t follow pattern:sample.int() uses complicated rule determine whether use\nfaster hash based method ’s applicable circumstances:\nuseHash = (!replace && .null(prob) && size <= n/2 && n > 1e+07))sample.int() uses complicated rule determine whether use\nfaster hash based method ’s applicable circumstances:\nuseHash = (!replace && .null(prob) && size <= n/2 && n > 1e+07))exists(), figures variable exists given environment,\nuses complex default determine environment look \nspecifically provided:\nenvir = ((missing(frame)) .environment() else sys.frame(frame))\n(NB: ?exists cheats hides long default documentation.)exists(), figures variable exists given environment,\nuses complex default determine environment look \nspecifically provided:\nenvir = ((missing(frame)) .environment() else sys.frame(frame))\n(NB: ?exists cheats hides long default documentation.)reshape() longest default argument base stats packages.\nsplit argument one two possible lists depending value\nsep argument:\nreshape(\n  split = (sep == \"\") {\n    list(regexp = \"[-Za-z][0-9]\", include = TRUE)\n  } else {\n    list(regexp = sep, include = FALSE, fixed = TRUE)\n  })\n)reshape() longest default argument base stats packages.\nsplit argument one two possible lists depending value\nsep argument:","code":"reshape(\n  split = if (sep == \"\") {\n    list(regexp = \"[A-Za-z][0-9]\", include = TRUE)\n  } else {\n    list(regexp = sep, include = FALSE, fixed = TRUE)\n  })\n)"},{"path":"def-short.html","id":"why-is-it-important-3","chapter":"14 Keep defaults short and sweet","heading":"14.3 Why is it important?","text":"","code":""},{"path":"def-short.html","id":"how-do-i-use-it-1","chapter":"14 Keep defaults short and sweet","heading":"14.4 How do I use it?","text":"three approaches:Set default value NULL calculate default \nargument NULL. Providing default NULL signals argument\noptional (Chapter 10) default requires\ncalculation.Set default value NULL calculate default \nargument NULL. Providing default NULL signals argument\noptional (Chapter 10) default requires\ncalculation.calculation complex, user might find useful \nscenarios, compute exported function documents exactly\nhappens.calculation complex, user might find useful \nscenarios, compute exported function documents exactly\nhappens.NULL meaningful, can’t use first approach, use \n“sentinel” object instead.NULL meaningful, can’t use first approach, use \n“sentinel” object instead.","code":""},{"path":"def-short.html","id":"arg-short-null","chapter":"14 Keep defaults short and sweet","heading":"14.4.1 NULL default","text":"common approach use NULL sentinel value indicates argument optional, non-trivial. pattern made substantially elegant infix %||% operator. can either get importing rlang, copying pasting utils.R:allows write code like (extracted ggplot2::geom_bar()). computes width first looking data, paramters, finally falling back computing resolution x variable:code colourbar legend: finds horizontal justification first looking guide settings, specific theme setting, title element, finally using 0 nothing else set:can see, %||% particularly well suited arguments default value found cascading system fallbacks.Don’t use %||% complex examples. example reshape() set split = NULL write:(probably also switch .null(sep) , make clear special behaviour.)","code":"\n`%||%` <- function(x, y) if (is.null(x)) y else x\nwidth <- data$width %||% params$width %||% (resolution(data$x, FALSE) * 0.9)\ntitle.hjust <- guide$title.hjust %||% \n  theme$legend.title.align %||% \n  title.theme$hjust %||% \n  0\nif (is.null(split)) {\n  if (sep == \"\") {\n    split <- list(regexp = \"[A-Za-z][0-9]\", include = TRUE)\n  } else {\n    split <- list(regexp = sep, include = FALSE, fixed = TRUE)\n  }\n}"},{"path":"def-short.html","id":"helper-function","chapter":"14 Keep defaults short and sweet","heading":"14.4.2 Helper function","text":"complicated cases, ’ll probably want pull code computes default separate function, many cases ’ll want export (document) function.good example pattern readr::show_progress(): ’s used every read_ function readr ’s sufficiently complicated don’t want copy paste functions. ’s also nice document file, rather cluttering file reading functions incidental details.","code":""},{"path":"def-short.html","id":"args-default-sentinel","chapter":"14 Keep defaults short and sweet","heading":"14.4.3 Sentinel value","text":"Sometimes default argument complex calculation don’t want include arguments list. ’d normally use NULL indicate ’s calculated default, NULL meaningful option. case, can use sentinel object.wrong way around? default always NULL special value use actually want NULL?Take purrr::reduce(): optional details argument called init. supplied, serves initial value computation. value (including NULL) can valid value. using sentinel value one case seemed like overkill.","code":"\nstr(ggplot2::waiver())\n#>  list()\n#>  - attr(*, \"class\")= chr \"waiver\"\n\nstr(purrr::done())\n#> List of 1\n#>  $ : symbol \n#>  - attr(*, \"class\")= chr [1:2] \"rlang_box_done\" \"rlang_box\"\n#>  - attr(*, \"empty\")= logi TRUE\n\nstr(rlang::zap())\n#>  list()\n#>  - attr(*, \"class\")= chr \"rlang_zap\""},{"path":"def-short.html","id":"how-do-i-remediate-existing-problems","chapter":"14 Keep defaults short and sweet","heading":"14.5 How do I remediate existing problems?","text":"function long default, can use three approaches remediate . long don’t accidentally change default value, affect function interface. Make sure test default operation function embarking change.","code":"\n# BEFORE\nsample.int <- function(n, \n                       size = n, \n                       replace = FALSE, \n                       prob = NULL, \n                       useHash = (!replace && is.null(prob) && size <= n/2 && n > 1e+07)\n                       ) {\n    if (useHash) {\n      .Internal(sample2(n, size))\n    } else {\n      .Internal(sample(n, size, replace, prob))\n    }\n}\n\n# AFTER\nsample.int <- function(n, \n                       size = n, \n                       replace = FALSE, \n                       prob = NULL, \n                       useHash = NULL) {\n  useHash <- useHash %||% !replace && is.null(prob) && size <= n/2 && n > 1e+07\n\n  if (useHash) {\n    .Internal(sample2(n, size))\n  } else {\n    .Internal(sample(n, size, replace, prob))\n  }\n}"},{"path":"def-inform.html","id":"def-inform","chapter":"15 Explain important defaults","heading":"15 Explain important defaults","text":"","code":""},{"path":"def-inform.html","id":"whats-the-pattern-4","chapter":"15 Explain important defaults","heading":"15.1 What’s the pattern?","text":"default value important, computation non-trivial, inform user value used. particularly important default value educated guess, want user change . also important descriptor arguments (Chapter 7) defaults.","code":""},{"path":"def-inform.html","id":"what-are-some-examples-7","chapter":"15 Explain important defaults","heading":"15.2 What are some examples?","text":"dplyr::left_join() friends automatically compute variables \njoin variables occur x y (called\nnatural join SQL). convenient, ’s heuristic \ndoesn’t always work.\n\nlibrary(nycflights13)\nlibrary(dplyr)\n\n# Correct    \n<- left_join(flights, airlines)\n#> Joining, = \"carrier\"\n\n# Incorrect\n<- left_join(flights, planes)\n#> Joining, = c(\"year\", \"tailnum\")\n\n# Error\n<- left_join(flights, airports)\n#> Error `left_join()`:\n#> ! `` must supplied `x` `y` common variables.\n#> ℹ use = character()` perform cross-join.dplyr::left_join() friends automatically compute variables \njoin variables occur x y (called\nnatural join SQL). convenient, ’s heuristic \ndoesn’t always work.readr::read_csv() reads csv file data frame. csv files\ndon’t store type variable, readr must guess types. order\nfast, read_csv() uses heuristics, might guess wrong. \nmaybe guesses correctly today, automated script runs two\nmonths time data format changed, might guess incorrectly\ngive weird downstream errors. reason, read_csv() prints\ncolumn specification way can copy--paste \ncode.\n\nlibrary(readr)\nmtcars <- read_csv(readr_example(\"mtcars.csv\"))\n#> Rows: 32 Columns: 11\n#> ── Column specification ────────────────────────────────────────────────────────\n#> Delimiter: \",\"\n#> dbl (11): mpg, cyl, disp, hp, drat, wt, qsec, vs, , gear, carb\n#> \n#> ℹ Use `spec()` retrieve full column specification data.\n#> ℹ Specify column types set `show_col_types = FALSE` quiet message.readr::read_csv() reads csv file data frame. csv files\ndon’t store type variable, readr must guess types. order\nfast, read_csv() uses heuristics, might guess wrong. \nmaybe guesses correctly today, automated script runs two\nmonths time data format changed, might guess incorrectly\ngive weird downstream errors. reason, read_csv() prints\ncolumn specification way can copy--paste \ncode.ggplot2::geom_histogram(), binwidth important parameter\nalways experiment . suggests \nrequired argument, ’s hard know values try ’ve\nseen plot. reason, ggplot2 provides suboptimal default \n30 bins: gets started, message tells modify.\n\nlibrary(ggplot2)\nggplot(diamonds, aes(carat)) + geom_histogram()\n#> `stat_bin()` using `bins = 30`. Pick better value `binwidth`.\nggplot2::geom_histogram(), binwidth important parameter\nalways experiment . suggests \nrequired argument, ’s hard know values try ’ve\nseen plot. reason, ggplot2 provides suboptimal default \n30 bins: gets started, message tells modify.installing packages, install.packages() informs value \nlib argument, defaults .libPath()[[1]]:\n\ninstall.packages(\"forcats\")\n# Installing package ‘/Users/hadley/R’\n# (‘lib’ unspecified)\n, however, terribly important (people use one library),\n’s easy ignore amongst output, message doesn’t\nrefer mechanism controls default (.libPaths()).installing packages, install.packages() informs value \nlib argument, defaults .libPath()[[1]]:, however, terribly important (people use one library),\n’s easy ignore amongst output, message doesn’t\nrefer mechanism controls default (.libPaths()).","code":"\nlibrary(nycflights13)\nlibrary(dplyr)\n\n# Correct    \nout <- left_join(flights, airlines)\n#> Joining, by = \"carrier\"\n\n# Incorrect\nout <- left_join(flights, planes)\n#> Joining, by = c(\"year\", \"tailnum\")\n\n# Error\nout <- left_join(flights, airports)\n#> Error in `left_join()`:\n#> ! `by` must be supplied when `x` and `y` have no common variables.\n#> ℹ use by = character()` to perform a cross-join.\nlibrary(readr)\nmtcars <- read_csv(readr_example(\"mtcars.csv\"))\n#> Rows: 32 Columns: 11\n#> ── Column specification ────────────────────────────────────────────────────────\n#> Delimiter: \",\"\n#> dbl (11): mpg, cyl, disp, hp, drat, wt, qsec, vs, am, gear, carb\n#> \n#> ℹ Use `spec()` to retrieve the full column specification for this data.\n#> ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\nlibrary(ggplot2)\nggplot(diamonds, aes(carat)) + geom_histogram()\n#> `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\ninstall.packages(\"forcats\")\n# Installing package into ‘/Users/hadley/R’\n# (as ‘lib’ is unspecified)"},{"path":"def-inform.html","id":"why-is-it-important-4","chapter":"15 Explain important defaults","heading":"15.3 Why is it important?","text":"two ways fire machine gun dark. can find \nexactly target (range, elevation, azimuth). can\ndetermine environmental conditions (temperature, humidity, air pressure,\nwind, ). can determine precise specifications \ncartridges bullets using, interactions \nactual gun firing. can use tables firing computer\ncalculate exact bearing elevation barrel. everything\nworks exactly specified, tables correct, environment\ndoesn’t change, bullets land close target.use tracer bullets.Tracer bullets loaded intervals ammo belt alongside regular\nammunition. ’re fired, phosphorus ignites leaves \npyrotechnic trail gun whatever hit. tracers \nhitting target, regular bullets.— Pragmatic ProgrammerI think valuable pattern helps balance two tensions function design:Forcing function user really think want .Forcing function user really think want .Trying helpful, user function can achieve goal \nquickly possible.Trying helpful, user function can achieve goal \nquickly possible.Often thoughts problem aided first attempt, even attempt wrong. Helps facilitate iteration: don’t sit contemplate hour write one perfectly formed line R code. take stab , look result, tweak.Taking default user really carefully think make decision , turning heurstic educated guess, reporting value, like tracer bullet.counterpoint pattern people don’t read repeated output. example, know cite R paper? ’s mentioned every time start R. Human brains extremely good filtering unchanging signals, means must use technique caution. every argument tells default uses, ’s effectively nothing: important signals get buried noise. ’ll see technique used handful places tidyverse.","code":""},{"path":"def-inform.html","id":"how-can-i-use-it","chapter":"15 Explain important defaults","heading":"15.4 How can I use it?","text":"use message need generate message computation default value. easiest way write small helper function. compute default value given inputs generate message() gives code copy paste function call.Take dplyr join functions, example. use function like :technique use generate code vary function function. rlang::expr_text() useful automatically creates code ’d use build character vector.avoid creating magical default (Chapter 13), either export document function, use technique Section 14.4.1:","code":"\ncommon_by <- function(x, y) {\n  common <- intersect(names(x), names(y))\n  if (length(common) == 0) {\n    stop(\"Must specify `by` when no common variables in `x` and `y`\", call. = FALSE)\n  }\n  \n  message(\"Computing common variables: `by = \", rlang::expr_text(common), \"`\")\n  common\n}\n\ncommon_by(data.frame(x = 1), data.frame(x = 1))\n#> Computing common variables: `by = \"x\"`\n#> [1] \"x\"\ncommon_by(flights, planes)\n#> Computing common variables: `by = c(\"year\", \"tailnum\")`\n#> [1] \"year\"    \"tailnum\"\nleft_join <- function(x, y, by = NULL) {\n  by <- by %||% common_by(x, y)\n}"},{"path":"def-user.html","id":"def-user","chapter":"16 User settable defaults","heading":"16 User settable defaults","text":"","code":""},{"path":"def-user.html","id":"whats-the-pattern-5","chapter":"16 User settable defaults","heading":"16.1 What’s the pattern?","text":"’s sometimes useful give user control default values, can set per session every session .Rprofile. , use getOption() default value.Note pattern general used control side-effects function, compute value. two primary uses controlling appearance output, particularly print() methods, setting default values generated templates.Related patterns:global option affects results computation (just \nside-effects), example Chapter 6.","code":""},{"path":"def-user.html","id":"what-are-some-examples-8","chapter":"16 User settable defaults","heading":"16.2 What are some examples?","text":"","code":""},{"path":"def-user.html","id":"why-is-it-important-5","chapter":"16 User settable defaults","heading":"16.3 Why is it important?","text":"","code":""},{"path":"def-user.html","id":"what-are-the-exceptions-3","chapter":"16 User settable defaults","heading":"16.4 What are the exceptions?","text":"","code":""},{"path":"def-user.html","id":"how-do-i-use-it-2","chapter":"16 User settable defaults","heading":"16.5 How do I use it?","text":"","code":""},{"path":"cs-rgb.html","id":"cs-rgb","chapter":"17 Case study: rgb()","heading":"17 Case study: rgb()","text":"Interface:Function name argument names.alpha default isn’t required.names required (imo).maxColorValue doens’t useful default, really needed (imo).Data frame rather matrix.Error function specification correctCheck data type, missingness.","code":"\nlibrary(rlang)\n\nrgba <- function(r, g, b, a = NULL) {\n  if (is.data.frame(r)) {\n    df <- r\n    if (!ncol(df) %in% c(3L, 4L)) {\n      abort(\"If `r` is data frame, it must have 3 or 4 columns.\")\n    }\n    \n    if (!missing(b) || !missing(g) || !missing(a)) {\n      abort(\"If `r` is a data frame, `b`, `g`, and `a` must not be set.\")\n    }\n    \n    r <- df[[1L]]\n    g <- df[[2L]]\n    b <- df[[3L]]\n    if (ncol(df) == 4) {\n      a <- df[[4L]]\n    }\n  }\n  \n  rgb(r, g, b, alpha = a, maxColorValue = 255)\n}\n\nrgba(16, 16, 16)\n#> [1] \"#101010\"\nrgba(data.frame(16, 16, 16))\n#> [1] \"#101010\"\nrgba(data.frame(16, 16))\n#> Error in `rgba()`:\n#> ! If `r` is data frame, it must have 3 or 4 columns.\nrgba(data.frame(16, 16, 16), 1)\n#> Error in `rgba()`:\n#> ! If `r` is a data frame, `b`, `g`, and `a` must not be set.\nrgba <- function(r, g, b, a = NULL) {\n  if (is.data.frame(r)) {\n    df <- r\n    if (!all(c(\"r\", \"g\", \"b\")) %in% names(df)) {\n      abort(\"If first argument is a data frame, it must have r, g, and b columns.\")\n    }\n    \n    if (!missing(b) || !missing(g) || !missing(a)) {\n      abort(\"If `r` is a data frame, `b`, `g`, and `a` must not be set.\")\n    }\n  } else {\n    # Handles vectorisation\n    df <- tibble(r = r, g = g, b = b, a = a) \n  }\n  \n  # Assumes this function checks types and gives informative error messages\n  rgb(df$r, df$g, df$b, alpha = df$a, maxColorValue = 255)\n}"},{"path":"dots-position.html","id":"dots-position","chapter":"18 Data, dots, details","heading":"18 Data, dots, details","text":"","code":""},{"path":"dots-position.html","id":"whats-the-pattern-6","chapter":"18 Data, dots, details","heading":"18.1 What’s the pattern?","text":"use ... function, put ? ’s obvious data arguments must come first. come next, dots details? pattern tells place ... data arguments (required arguments supply key “data” function) details arguments (optional additional arguments control finer details function).","code":""},{"path":"dots-position.html","id":"what-are-some-examples-9","chapter":"18 Data, dots, details","heading":"18.2 What are some examples?","text":"Many functions base R take data, details, dots:doesn’t cause many problems people fully spell names details arguments. However, summary functions take data via dots, details.allows functions take number input vectors, two different interfaces make easy users construct calls technically valid, don’t return desired result.’re expecting median() work like sum(), might call way:silently returns incorrect result median() arguments x, na.rm, .... user must remember median() – mean() ! – require data packed single vector.","code":"\nargs(unique)\n#> function (x, incomparables = FALSE, ...) \n#> NULL\nargs(median)\n#> function (x, na.rm = FALSE, ...) \n#> NULL\nsum(2, 3, 10)\n#> [1] 15\nprod(2, 3, 10)\n#> [1] 60\n\nargs(sum)\n#> function (..., na.rm = FALSE) \n#> NULL\nargs(prod)\n#> function (..., na.rm = FALSE) \n#> NULL\nmedian(2, 3, 10)\n#> [1] 2\nmedian(c(2, 3, 10))\n#> [1] 3\nmean(c(2, 3, 10))\n#> [1] 5"},{"path":"dots-position.html","id":"what-is-it-important","chapter":"18 Data, dots, details","heading":"18.3 What is it important?","text":"three primary advantages:forces user function fully name detail arguments,\narguments come ... never matched position\npartially name. Using full names details arguments good practice,\nmakes code easier read.forces user function fully name detail arguments,\narguments come ... never matched position\npartially name. Using full names details arguments good practice,\nmakes code easier read.can easily add new detail arguments without changing meaning \nexisting function calls. makes easy extend function \nnew capabilities, don’t need worry changing existing\ncode.can easily add new detail arguments without changing meaning \nexisting function calls. makes easy extend function \nnew capabilities, don’t need worry changing existing\ncode.coupled “inspect dots” (Chapter 21),\n“dot prefix” (Chapter 20) minimises chances \nmisspelled arguments names silently go astray.coupled “inspect dots” (Chapter 21),\n“dot prefix” (Chapter 20) minimises chances \nmisspelled arguments names silently go astray.payoff pattern huge: protects fairly unusual failure mode. However, failure mode silent (easy miss), pattern easy apply, think payoff still worth .","code":""},{"path":"dots-position.html","id":"how-do-i-do-it","chapter":"18 Data, dots, details","heading":"18.4 How do I do it?","text":"Following pattern simple: just identity arguments data, arguments details put … .","code":""},{"path":"dots-position.html","id":"how-do-i-remediate-it","chapter":"18 Data, dots, details","heading":"18.5 How do I remediate it?","text":"’ve already published function ’ve put ... wrong place, ’s easy fix. ’ll need use function ellipsis package check ... expected (e.g. Chapters 21 19). Since using full names details arguments good practice, making change typically affect little existing code, interface change advertised prominently.can use approach make safer version median():","code":"\nold_interface <- function(x, data1 = 1, data2 = 2, ...) {\n}\n\nnew_interace <- function(x, ..., data1 = 1, data2 = 2) {\n  ellipsis::check_dots_used()\n}\nsafe_median <- function(x, ..., na.rm = FALSE) {\n  ellipsis::check_dots_used()\n  median(x, ..., na.rm = na.rm)\n}\n\nsafe_median(2, 3, 10)\n#> Error in `safe_median()`:\n#> ! Arguments in `...` must be used.\n#> ✖ Problematic arguments:\n#> • ..1 = 3\n#> • ..2 = 10"},{"path":"dots-data.html","id":"dots-data","chapter":"19 Making data with …","heading":"19 Making data with …","text":"","code":""},{"path":"dots-data.html","id":"whats-the-problem-4","chapter":"19 Making data with …","heading":"19.1 What’s the problem?","text":"number functions take ... save user create vector :","code":""},{"path":"dots-data.html","id":"what-are-some-examples-10","chapter":"19 Making data with …","heading":"19.2 What are some examples?","text":"mapply()","code":"\nsum(c(1, 1, 1))\n#> [1] 3\n# can be shortened to:\nsum(1, 1, 1)\n#> [1] 3\n\nf <- factor(c(\"a\", \"b\", \"c\", \"d\"), levels = c(\"b\", \"c\", \"d\", \"a\"))\nf\n#> [1] a b c d\n#> Levels: b c d a\nfct_relevel(f, c(\"b\", \"a\"))\n#> [1] a b c d\n#> Levels: b a c d\n# can be shortened to:\nfct_relevel(f, \"b\", \"a\")\n#> [1] a b c d\n#> Levels: b a c d"},{"path":"dots-data.html","id":"why-is-it-important-6","chapter":"19 Making data with …","heading":"19.3 Why is it important?","text":"general, think best avoid using ... purpose relatively small benefit, reducing typing three letters c(), number costs:can give misleading impression functions \nfamily work way. example, ’re internalised sum()\nworks, might predict mean() works way, \n:\n\nmean(c(1, 2, 3))\n#> [1] 2\nmean(1, 2, 3)\n#> [1] 1\n(See Chapter 18 learn doesn’t give \nerror message.)can give misleading impression functions \nfamily work way. example, ’re internalised sum()\nworks, might predict mean() works way, \n:(See Chapter 18 learn doesn’t give \nerror message.)makes harder adapt function new uses. example,\nfct_relevel() can also called function:\n\nfct_relevel(f, sort)\n#> [1] b c d\n#> Levels: b c d\nfct_relevel() took input single vector, easily\nextend also work functions:\n\nfct_relevel <- function(f, x) {\n  (.function(x)) {\n    x <- f(levels(x))\n  }\n}\nHowever, fct_relevel() uses dots, implementation needs \ncomplicated:\n\nfct_relevel <- function(f, ...) {\n  (dots_n(...) == 1L && .function(..1)) {\n    levels <- fun(levels(x))\n  } else {\n    levels <- c(...)\n  }\n}makes harder adapt function new uses. example,\nfct_relevel() can also called function:fct_relevel() took input single vector, easily\nextend also work functions:However, fct_relevel() uses dots, implementation needs \ncomplicated:","code":"\nmean(c(1, 2, 3))\n#> [1] 2\nmean(1, 2, 3)\n#> [1] 1\nfct_relevel(f, sort)\n#> [1] a b c d\n#> Levels: a b c d\nfct_relevel <- function(f, x) {\n  if (is.function(x)) {\n    x <- f(levels(x))\n  }\n}\nfct_relevel <- function(f, ...) {\n  if (dots_n(...) == 1L && is.function(..1)) {\n    levels <- fun(levels(x))\n  } else {\n    levels <- c(...)\n  }\n}"},{"path":"dots-data.html","id":"what-are-the-exceptions-4","chapter":"19 Making data with …","heading":"19.4 What are the exceptions?","text":"Note examples , ... used collect single details argument. ’s ok use ... collect data, paste(), data.frame(), list().","code":""},{"path":"dots-data.html","id":"how-can-remediate-it","chapter":"19 Making data with …","heading":"19.5 How can remediate it?","text":"’ve already published function ’ve used ... purpose can change interface adding new argument front ..., warning anything ends ....interface change, prominently advertised packages.","code":"\nold_foo <- function(x, ...) {\n}\n\nnew_foo <- function(x, y, ...) {\n  if (rlang::dots_n(...) > 0) {\n    warning(\"Use of `...` is now deprecated. Please put all arguments in `y`\")\n    y <- c(y, ...)\n  }\n}"},{"path":"dots-data.html","id":"how-can-i-protect-myself","chapter":"19 Making data with …","heading":"19.6 How can I protect myself?","text":"feel tradeoff worth (.e. ’s extremely frequently used function savings time considerable), need take steps minimise downsides.easiest ’re constructing vector shouldn’t names. case, can call ellipsis::check_dots_unnamed() ensure named arguments accidentally passed .... protects following undesirable behaviour sum():want vector names, problem harder, ’s relatively little can. ’ll need ensure arguments get . prefix (minimise chances mismatch) think carefully might detect problems thinking expect type c(...). far know, general techniques, ’ll think problem case--case basis.","code":"\nsum(1, 1, 1, na.omit = TRUE)\n#> [1] 4\n\nsafe_sum <- function(..., na.rm = TRUE) {\n  ellipsis::check_dots_unnamed()\n  sum(c(...), na.rm = na.rm)\n}\nsafe_sum(1, 1, 1, na.omit = TRUE)\n#> Error in `safe_sum()`:\n#> ! Arguments in `...` must be passed by position, not name.\n#> ✖ Problematic argument:\n#> • na.omit = TRUE"},{"path":"dots-data.html","id":"selecting-variables","chapter":"19 Making data with …","heading":"19.7 Selecting variables","text":"number funtions tidyverse use ... selecting variables. example, tidyr::fill() lets fill missing values based previous row:functions work like include call tidyselect::vars_select() looks something like :now think interface mistake suffers problem sum(): ’re using ... save little typing. can eliminate use dots requiring user use c(). (change also requires explicit quoting unquoting vars since ’re longer using ....)words, believe better interface fill() :tidyverse functions like dplyr’s scoped verbs ggplot2::facet_grid() require user explicitly quote input. now believe also suboptimal interface typing (var() longer c(), must quote even single variables), arguments require inputs explicitly quoted rare tidyverse.said, unlikely ever change functions, benefit smaller (primarily improved consistency) costs high, impossible switch evaluated argument quoted argument without breaking backward compatibility small percentage cases.","code":"\ndf <- tribble(\n  ~year,  ~month, ~day,\n  2020,  1,       1,\n  NA,    NA,      2,\n  NA,    NA,      3,\n  NA,    2,       1\n)\ndf %>% fill(year, month)\n#> # A tibble: 4 × 3\n#>    year month   day\n#>   <dbl> <dbl> <dbl>\n#> 1  2020     1     1\n#> 2  2020     1     2\n#> 3  2020     1     3\n#> 4  2020     2     1\nfind_vars <- function(data, ...) {\n  tidyselect::vars_select(names(data), ...)\n}\n\nfind_vars(df, year, month)\n#>    year   month \n#>  \"year\" \"month\"\nfoo <- function(data, vars) {\n  tidyselect::vars_select(names(data), !!enquo(vars))\n}\n\nfind_vars(df, c(year, month))\n#>    year   month \n#>  \"year\" \"month\"\ndf %>% fill(c(year, month))\n# existing interface\ndplyr::mutate_at(mtcars, vars(cyl:vs), mean)\n# what I would create today\ndplyr::mutate_at(mtcars, c(cyl:vs), mean)\n\n# existing interface\nggplot2::facet_grid(rows = vars(drv), cols = vars(vs, am))\n# what I would create today\nggplot2::facet_grid(rows = drv, cols = c(vs, am))"},{"path":"dots-prefix.html","id":"dots-prefix","chapter":"20 Dot prefix","heading":"20 Dot prefix","text":"","code":""},{"path":"dots-prefix.html","id":"whats-the-pattern-7","chapter":"20 Dot prefix","heading":"20.1 What’s the pattern?","text":"using ... create data structure, passing ... user-supplied function, add . prefix named arguments. reduces (eliminate) chances matching argument wrong level. Additionally, always provide mechanism allows escape use name needed.(important ignore names: e.g. cat().)","code":"\nlibrary(purrr)"},{"path":"dots-prefix.html","id":"what-are-some-examples-11","chapter":"20 Dot prefix","heading":"20.2 What are some examples?","text":"Look arguments functions purrr:Notice named arguments start .. reduces chance incorrectly match argument map(), rather argument .f. Obviously can’t eliminate .Escape mechanism anonymous function. Little easier access purrr::map() since can create ~, much less typing function() {}. example, imagine want …Example: https://jennybc.github.io/purrr-tutorial/ls02_map-extraction-advanced.html#list_inside_a_data_frame","code":"\nargs(map)\n#> function (.x, .f, ...) \n#> NULL\nargs(reduce)\n#> function (.x, .f, ..., .init, .dir = c(\"forward\", \"backward\")) \n#> NULL\nargs(detect)\n#> function (.x, .f, ..., .dir = c(\"forward\", \"backward\"), .right = NULL, \n#>     .default = NULL) \n#> NULL"},{"path":"dots-prefix.html","id":"case-study-dplyr-verbs","chapter":"20 Dot prefix","heading":"20.3 Case study: dplyr verbs","text":"Escape hatch :=.Ooops:","code":"\nargs(dplyr::filter)\n#> function (.data, ..., .preserve = FALSE) \n#> NULL\nargs(dplyr::group_by)\n#> function (.data, ..., .add = FALSE, .drop = group_by_drop_default(.data)) \n#> NULL\nargs(dplyr::left_join)\n#> function (x, y, by = NULL, copy = FALSE, suffix = c(\".x\", \".y\"), \n#>     ..., keep = FALSE) \n#> NULL"},{"path":"dots-prefix.html","id":"other-approaches-in-base-r","chapter":"20 Dot prefix","heading":"20.4 Other approaches in base R","text":"Base R uses two alternative methods: uppercase _ prefix.apply family tends use uppercase function names reason. Unfortunately functions little inconsitent makes hard see pattern. think dot prefix better ’s easier type (don’t hold shift-key one finger).Reduce() friends avoid problem altogether accepting ..., requiring user creates anonymous functions. verbose, particularly without shortcuts create functions.transform() goes step uses non-syntactic variable name.Using non-syntactic variable names means must always surrounded `. means user even less likely use ., increases friction writing function. opinion, trade-worth .","code":"\nargs(lapply)\n#> function (X, FUN, ...) \n#> NULL\nargs(sapply)\n#> function (X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE) \n#> NULL\nargs(apply)\n#> function (X, MARGIN, FUN, ..., simplify = TRUE) \n#> NULL\nargs(mapply)\n#> function (FUN, ..., MoreArgs = NULL, SIMPLIFY = TRUE, USE.NAMES = TRUE) \n#> NULL\nargs(tapply)\n#> function (X, INDEX, FUN = NULL, ..., default = NA, simplify = TRUE) \n#> NULL\nargs(transform)\n#> function (`_data`, ...) \n#> NULL"},{"path":"dots-prefix.html","id":"what-are-the-exceptions-5","chapter":"20 Dot prefix","heading":"20.5 What are the exceptions?","text":"tryCatch(): names give classes , long don’t create \ncondition class called expr finally (weird!) \ndon’t need worry matchestryCatch(): names give classes , long don’t create \ncondition class called expr finally (weird!) \ndon’t need worry matches","code":""},{"path":"dots-inspect.html","id":"dots-inspect","chapter":"21 Inspect the dots","heading":"21 Inspect the dots","text":"","code":""},{"path":"dots-inspect.html","id":"whats-the-pattern-8","chapter":"21 Inspect the dots","heading":"21.1 What’s the pattern?","text":"Whenever use ... S3 generic allow methods add custom arguments, inspect dots make sure every argument used. can also use approach passing ... overly permissive function.","code":""},{"path":"dots-inspect.html","id":"what-are-some-examples-12","chapter":"21 Inspect the dots","heading":"21.2 What are some examples?","text":"don’t use technique easy end functions silently return incorrect result argument names misspelled.","code":"\n# Misspelled\nweighted.mean(c(1, 0, -1), wt = c(10, 0, 0))\n#> [1] 0\nmean(c(1:9, 100), trim = 0.1)\n#> [1] 5.5\n\n# Correct\nweighted.mean(c(1, 0, -1), w = c(10, 0, 0))\n#> [1] 1\nmean(c(1:9, 100), trim = 0.1)\n#> [1] 5.5"},{"path":"dots-inspect.html","id":"how-do-i-do-it-1","chapter":"21 Inspect the dots","heading":"21.3 How do I do it?","text":"Add call ellipsis::check_dots_used() generic call UseMethod(). automatically adds exit handler, checks ever element ... evaluated just prior function returnning.can see action creating safe wrapper around cut(), different arguments numeric date methods.","code":"\nsafe_cut <- function(x, breaks, ..., right = TRUE) {\n  ellipsis::check_dots_used()\n  UseMethod(\"safe_cut\")\n}\n\nsafe_cut.numeric <- function(x, breaks, ..., right = TRUE, include.lowest = FALSE) {\n  cut(x, breaks = breaks, right = right, include.lowest = include.lowest)\n}\n\nsafe_cut.Date <- function(x, breaks, ..., right = TRUE, start.on.monday = TRUE) {\n  cut(x, breaks = breaks, right = right, start.on.monday = start.on.monday)\n}"},{"path":"dots-inspect.html","id":"what-are-the-limitations","chapter":"21 Inspect the dots","heading":"21.3.1 What are the limitations?","text":"Accurately detecting problem hard one place information needed tell argument superfluous (precise details beyond scope text). Instead ellipsis package takes advantage R’s lazy evaluation inspects internal components ... see evaluation forced.function called primarily side-effects, error occur side-effect happened, making confusing result. best can warning, generated ellipsis::warn_dots_unused()function captures components ... using enquo() match.call(), can use technique. also means use check_dots_used(), method author can choose add quoted argument. think ok quoting vs. evaluating part interface generic, methods change interface, ’s fine author generic make decision method authors.","code":""},{"path":"dots-inspect.html","id":"what-are-other-uses","chapter":"21 Inspect the dots","heading":"21.3.2 What are other uses?","text":"technique can also used wrapping functions. example, stringr::str_sort() takes ... passes stringi::stri_opts_collator(). March 2019, str_sort() looked like :wrapper useful decouples str_sort() stri_opts_collator() meaning stri_opts_collator() gains new arguments users str_sort() can take advantage immediately. arguments stri_opts_collator() sufficiently arcane don’t need exposed directly stringr, designed minimise cognitive load user, hiding full complexity string handling.(importance locale argument comes “hidden inputs”, Chapter 6.)However, stri_opts_collator() deliberately ignores arguments .... means misspellings silently ignored:can work around behaviour adding check_dots_used() str_sort():Note, however, ’s better figure stri_opts_collator() ignores ... first place. can see discussion https://github.com/gagolews/stringi/issues/347.See https://github.com/r-lib/devtools/issues/2016 discussion using another discussion using devtools::install_github() similar situation, complicated chain calls: devtools::install_github() -> install.packages() -> download.file().","code":"\nstr_sort <- function(x, decreasing = FALSE, na_last = TRUE, locale = \"en\",  numeric = FALSE, ...) \n{\n    stringi::stri_sort(x, \n      decreasing = decreasing, \n      na_last = na_last, \n      opts_collator = stringi::stri_opts_collator(\n        locale, \n        numeric = numeric, \n        ...\n      )\n    )\n}\nx <- c(\"x1\", \"x100\", \"x2\")\nstr_sort(x)\n#> [1] \"x1\"   \"x100\" \"x2\"\nstr_sort(x, numeric = TRUE)\n#> [1] \"x1\"   \"x2\"   \"x100\"\nstr_sort(x, numric = TRUE)\n#> Warning in stringi::stri_opts_collator(locale, numeric = numeric, ...): Unknown\n#> option to `stri_opts_collator`.\n#> [1] \"x1\"   \"x100\" \"x2\"\nstr_sort <- function(x, decreasing = FALSE, na_last = TRUE, locale = \"en\",  numeric = FALSE, ...) \n{\n    ellipsis::check_dots_used()\n  \n    stringi::stri_sort(x, \n      decreasing = decreasing, \n      na_last = na_last, \n      opts_collator = stringi::stri_opts_collator(\n        locale, \n        numeric = numeric, \n        ...\n      )\n    )\n}\n\nstr_sort(x, numric = TRUE)\n#> Warning in stringi::stri_opts_collator(locale, numeric = numeric, ...): Unknown\n#> option to `stri_opts_collator`.\n#> Error in `str_sort()`:\n#> ! Arguments in `...` must be used.\n#> ✖ Problematic argument:\n#> • numric = TRUE"},{"path":"cs-mapply-pmap.html","id":"cs-mapply-pmap","chapter":"22 Case study: mapply() vs pmap()","heading":"22 Case study: mapply() vs pmap()","text":"’s useful compare mapply() purrr::pmap(). attempt solve similar problem, extending lapply()/map() handle iterating number arguments.’ll ignore simplify = TRUE makes mapply() type-unstable default. ’ll also ignore USE.NAMES = TRUE isn’t just using names, using character vector input names output. think ’s reused lapply() without much thought ’s names first argument matter.mapply() takes function apply first argument, followed arbitrary number arguments pass function. makes different apply() functions (including lapply(), sapply() tapply()), take data first argument. mapply() take ... first arguments, force FUN always named, also make inconsistent apply() functions.pmap() avoids problem taking list vectors, rather individual vectors .... allows pmap() use ... another purpose, instead MoreArg argument (list), pmap() passes ... .f.’s subtle difference doesn’t matter cases - mapply() fixed recycled length pattern whereas pmap(). TODO: figure example ’s clear.(Also note pmap() uses . prefix avoid problem described Chapter 20.)","code":"\nlibrary(purrr)\nargs(mapply)\n#> function (FUN, ..., MoreArgs = NULL, SIMPLIFY = TRUE, USE.NAMES = TRUE) \n#> NULL\nargs(pmap)\n#> function (.l, .f, ...) \n#> NULL\nx <- c(\"apple\", \"banana\", \"cherry\")\npattern <- c(\"p\", \"n\", \"h\")\nreplacement <- c(\"x\", \"f\", \"q\")\n\nmapply(gsub, pattern, replacement, x)\n#>        p        n        h \n#>  \"axxle\" \"bafafa\" \"cqerry\"\n\nmapply(gsub, pattern, replacement, x)\n#>        p        n        h \n#>  \"axxle\" \"bafafa\" \"cqerry\"\npurrr::pmap_chr(list(pattern, replacement, x), gsub)\n#> [1] \"axxle\"  \"bafafa\" \"cqerry\"\nmapply(toupper, letters[1:3])\n#>   a   b   c \n#> \"A\" \"B\" \"C\"\nmapply(toupper, letters[1:3], USE.NAMES = FALSE)\n#> [1] \"A\" \"B\" \"C\"\nmapply(toupper, setNames(letters[1:3], c(\"X\", \"Y\", \"Z\")))\n#>   X   Y   Z \n#> \"A\" \"B\" \"C\"\n\npmap_chr(list(letters[1:3]), toupper)\n#> [1] \"A\" \"B\" \"C\"\nmapply(gsub, pattern, replacement, x, fixed = TRUE)\n#>        p        n        h \n#>  \"axxle\" \"bafafa\" \"cqerry\"\npurrr::pmap_chr(list(pattern, replacement, x), gsub, fixed = TRUE)\n#> [1] \"axxle\"  \"bafafa\" \"cqerry\""},{"path":"out-multi.html","id":"out-multi","chapter":"23 Returning multiple values","heading":"23 Returning multiple values","text":"","code":""},{"path":"out-multi.html","id":"different-sizes","chapter":"23 Returning multiple values","heading":"23.1 Different sizes","text":"Use list. Name .return type output multiple functions, create function consistently creates exact format (avoid accidentally inconsistency), consider making S3 class (can custom print method).","code":""},{"path":"out-multi.html","id":"same-size","chapter":"23 Returning multiple values","heading":"23.2 Same size","text":"function returns two vectors size, general rule return tibble:matrix work vectors type (factor Date), doesn’t make easy extract individual values, easily input tidyverse functions.matrix work vectors type (factor Date), doesn’t make easy extract individual values, easily input tidyverse functions.list doesn’t capture constraint vectors length.list doesn’t capture constraint vectors length.data frame ok don’t want take dependency tibble, need remember drawbacks: columns character vectors ’ll need remember use stringsAsFactors = FALSE, print method confusing list- df-cols (create modifying existing data frame, calling data.frame()). (Example: weird glue returned tibbles function.)data frame ok don’t want take dependency tibble, need remember drawbacks: columns character vectors ’ll need remember use stringsAsFactors = FALSE, print method confusing list- df-cols (create modifying existing data frame, calling data.frame()). (Example: weird glue returned tibbles function.)","code":""},{"path":"out-multi.html","id":"case-study-str_locate","chapter":"23 Returning multiple values","heading":"23.3 Case study: str_locate()","text":"e.g. str_locate(), str_locate_all()Interaction str_sub().","code":""},{"path":"out-type-stability.html","id":"out-type-stability","chapter":"24 Type-stability","heading":"24 Type-stability","text":"less need know function’s inputs predict type output, better. Ideally, function either always return type thing, return something can trivially computed inputs.function type-stable satisfies two conditions:can predict output type based input types\n(values).can predict output type based input types\n(values).function uses ..., order arguments affect \noutput type.function uses ..., order arguments affect \noutput type.","code":"\nlibrary(vctrs)"},{"path":"out-type-stability.html","id":"simple-examples","chapter":"24 Type-stability","heading":"24.1 Simple examples","text":"purrr::map() base::lapply() trivially type-stable \nalways return lists.purrr::map() base::lapply() trivially type-stable \nalways return lists.paste() type stable always returns character vector.\n\nvec_ptype(paste(1))\n#> character(0)\nvec_ptype(paste(\"x\"))\n#> character(0)paste() type stable always returns character vector.base::mean(x) almost always returns type output x.\nexample, mean numeric vector numeric vector, mean\ndate-time date-time.\n\nvec_ptype(mean(1))\n#> numeric(0)\nvec_ptype(mean(Sys.time()))\n#> POSIXct length 0base::mean(x) almost always returns type output x.\nexample, mean numeric vector numeric vector, mean\ndate-time date-time.ifelse() type-stable output type depends value:\n\nvec_ptype(ifelse(NA, 1L, 2))\n#> <unspecified> [0]\nvec_ptype(ifelse(FALSE, 1L, 2))\n#> numeric(0)\nvec_ptype(ifelse(TRUE, 1L, 2))\n#> integer(0)ifelse() type-stable output type depends value:","code":"\nvec_ptype(paste(1))\n#> character(0)\nvec_ptype(paste(\"x\"))\n#> character(0)\nvec_ptype(mean(1))\n#> numeric(0)\nvec_ptype(mean(Sys.time()))\n#> POSIXct of length 0\nvec_ptype(ifelse(NA, 1L, 2))\n#> <unspecified> [0]\nvec_ptype(ifelse(FALSE, 1L, 2))\n#> numeric(0)\nvec_ptype(ifelse(TRUE, 1L, 2))\n#> integer(0)"},{"path":"out-type-stability.html","id":"more-complicated-examples","chapter":"24 Type-stability","heading":"24.2 More complicated examples","text":"functions complex take multiple input types return single output type. includes functions like c() ifelse(). rules governing base R functions idiosyncratic, function tends apply ’s slightly different set rules. Tidy functions use consistent set rules provided vctrs package.","code":""},{"path":"out-type-stability.html","id":"challenge-the-median","chapter":"24 Type-stability","heading":"24.3 Challenge: the median","text":"challenging example median(). median vector value (evenly possible) splits vector lower half upper half. absence ties, mean(x > median(x)) == mean(x <= median(x)) == 0.5. median straightforward compute odd lengths: simply order vector pick value middle, .e. sort(x)[(length(x) - 1) / 2]. ’s clear type output type x, algorithm can applied vector can ordered.vector even length? case, ’s longer unique median, convention usually take mean middle two numbers.R, makes median() type-stable:Base R doesn’t appear follow consistent principle computing median vector length 2. Factors throw error, dates (even though ’s date half way two days differ odd number days).clear, problems caused behaviour quite small practice, makes analysis median() complex, makes difficult decide principle adhere creating median methods new vector classes.","code":"\ntypeof(median(1:3))\n#> [1] \"integer\"\ntypeof(median(1:4))\n#> [1] \"double\"\nmedian(factor(1:2))\n#> Error in median.default(factor(1:2)): need numeric data\nmedian(Sys.Date() + 0:1)\n#> [1] \"2022-11-01\"\nmedian(\"foo\")\n#> [1] \"foo\"\nmedian(c(\"foo\", \"bar\"))\n#> Warning in mean.default(sort(x, partial = half + 0L:1L)[half + 0L:1L]): argument\n#> is not numeric or logical: returning NA\n#> [1] NA"},{"path":"out-type-stability.html","id":"exercises","chapter":"24 Type-stability","heading":"24.4 Exercises","text":"date like integer? inconsistent?\n\nvec_ptype(mean(Sys.Date()))\n#> Date length 0\nvec_ptype(mean(1L))\n#> numeric(0)date like integer? inconsistent?","code":"\nvec_ptype(mean(Sys.Date()))\n#> Date of length 0\nvec_ptype(mean(1L))\n#> numeric(0)"},{"path":"out-vectorisation.html","id":"out-vectorisation","chapter":"25 Vectorisation","heading":"25 Vectorisation","text":"Vectorisation two meanings: can refer either interface function, implementation.\ncan make precise statement vectorised interface . function, f, vectorised vector argument, x, iff f(x)[[]] equals f(x[[]]), .e. can exchange order subsetting function application. generalises naturally arguments: say f vectorised x y f(x[[]], y[[]]) equals f(x, y)[[]]. function can arguments vectorised , f(x, ...)[[]] equals f(x[[]], ...).harder define vectorised implementation. ’s necessary function vectorised implementation vectorised interface, also must possess property computational efficiency. ’s hard make precise, generally means explicit loop, loop written C C++, R.","code":""},{"path":"out-invisible.html","id":"out-invisible","chapter":"26 Side-effect functions should return invisibly","heading":"26 Side-effect functions should return invisibly","text":"","code":""},{"path":"out-invisible.html","id":"whats-the-pattern-9","chapter":"26 Side-effect functions should return invisibly","heading":"26.1 What’s the pattern?","text":"function called primarily side-effects, invisibly return useful output. ’s obvious output, return first argument. makes possible use function pipeline.","code":""},{"path":"out-invisible.html","id":"what-are-some-examples-13","chapter":"26 Side-effect functions should return invisibly","heading":"26.2 What are some examples?","text":"print(x) invisibly returns printed object.print(x) invisibly returns printed object.x <- y invisible returns y. makes possible chain\ntogether multiple assignments x <- y <- z <- 1x <- y invisible returns y. makes possible chain\ntogether multiple assignments x <- y <- z <- 1readr::write_csv() invisibly returns data frame saved.readr::write_csv() invisibly returns data frame saved.purrr::walk() invisibly returns vector iterated .purrr::walk() invisibly returns vector iterated .fs:file_copy(, ) returns tofs:file_copy(, ) returns tooptions() par() invisibly return previous value can\nreset .exit().options() par() invisibly return previous value can\nreset .exit().","code":""},{"path":"out-invisible.html","id":"why-is-it-important-7","chapter":"26 Side-effect functions should return invisibly","heading":"26.3 Why is it important?","text":"Invisibly returning first argument allows call function mid-pipe side-effects allow primary data continue flowing pipe. useful generating intermediate diagnostics, saving multiple output formats.Functions modify global state, like options() par(), return previous value variables. , combination Section 10.3.2, makes possible easily reset effect change:","code":"\nlibrary(dplyr, warn.conflicts = FALSE)\nlibrary(tibble)\n\nmtcars %>%\n  as_tibble() %>% \n  filter(cyl == 6) %>% \n  print() %>% \n  group_by(vs) %>% \n  summarise(mpg = mean(mpg))\n#> # A tibble: 7 × 11\n#>     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n#>   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n#> 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4\n#> 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4\n#> 3  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1\n#> 4  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1\n#> 5  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4\n#> 6  17.8     6  168.   123  3.92  3.44  18.9     1     0     4     4\n#> 7  19.7     6  145    175  3.62  2.77  15.5     0     1     5     6\n#> # A tibble: 2 × 2\n#>      vs   mpg\n#>   <dbl> <dbl>\n#> 1     0  20.6\n#> 2     1  19.1\nlibrary(readr)\n\nmtcars %>% \n  write_csv(\"mtcars.csv\") %>% \n  write_tsv(\"mtcars.tsv\")\n\nunlink(c(\"mtcars.csv\", \"mtcars.tsv\"))\nlibrary(fs)\n\npaths <- file_temp() %>%\n  dir_create() %>%\n  path(letters[1:5]) %>%\n  file_create()\npaths\n#> /tmp/RtmpUceado/file32bd7128070f/a /tmp/RtmpUceado/file32bd7128070f/b \n#> /tmp/RtmpUceado/file32bd7128070f/c /tmp/RtmpUceado/file32bd7128070f/d \n#> /tmp/RtmpUceado/file32bd7128070f/e\nx <- runif(1)\nold <- options(digits = 3)\nx\n#> [1] 0.251\n\noptions(old)\nx\n#> [1] 0.2508593"},{"path":"err-call.html","id":"err-call","chapter":"27 Error call","heading":"27 Error call","text":"Don’t display call generating error message. Either use stop(call. = FALSE) rlang::abort() avoid .? Typically doesn’t display enough information find source call (since errors top-level function calls), can expect people either use RStudio, know call traceback().","code":""},{"path":"err-constructor.html","id":"err-constructor","chapter":"28 Error constructors","heading":"28 Error constructors","text":"","code":""},{"path":"err-constructor.html","id":"whats-the-pattern-10","chapter":"28 Error constructors","heading":"28.1 What’s the pattern?","text":"Following rule three, whenever generate error three places, extract common function, called error constructor. function create custom condition contains components can easily tested conditionMessage() method generates user friendly error messages.(new pattern currently rolling across tidyverse; ’s currently found packages.)","code":"\nlibrary(rlang)"},{"path":"err-constructor.html","id":"why-is-this-important-1","chapter":"28 Error constructors","heading":"28.2 Why is this important?","text":"don’t use custom condition, can check function\ngenerated correct error matching text error message\nregular expression. fragile text error messages\nchanges relatively frequently, causing spurious test failures.don’t use custom condition, can check function\ngenerated correct error matching text error message\nregular expression. fragile text error messages\nchanges relatively frequently, causing spurious test failures.can use custom conditions one-errors, generally extra\nimplementation work worth pay . ’s recommend \nusing error constructor repeated errors.can use custom conditions one-errors, generally extra\nimplementation work worth pay . ’s recommend \nusing error constructor repeated errors.gives precise control error handling tryCatch().\nparticularly useful packages may able give\nuseful high-level error mesasges wrapping specific low-level\nerror.gives precise control error handling tryCatch().\nparticularly useful packages may able give\nuseful high-level error mesasges wrapping specific low-level\nerror.start using technique error messages can create\nhierarchy errors allows borrow behaviour, reducing \namount code need write.start using technique error messages can create\nhierarchy errors allows borrow behaviour, reducing \namount code need write.identified errors can thrown function,\ncan add @section Throws: documentation precisely\ndescribes possible failure modes.identified errors can thrown function,\ncan add @section Throws: documentation precisely\ndescribes possible failure modes.","code":""},{"path":"err-constructor.html","id":"what-does-an-error-constructor-do","chapter":"28 Error constructors","heading":"28.3 What does an error constructor do?","text":"error constructor similar S3 constructor, job extract repeated code generate rich object can easily computed . primary difference instead creating returning new object, creates custom error immediately throws abort().’s simple imaginary error might thrown fs couldn’t find file:Note naming scheme:function called stop_{error_type}function called stop_{error_type}error class {package}_error_{error_type}.error class {package}_error_{error_type}.function one argument varying part error, argument passed onto abort() stored condition object.generate error message shown user, provide conditionMessage() method:method must exported, defining method generic another package, often use glue::glue_data() assemble components condition string. See https://style.tidyverse.org/error-messages.html advice writing error message.","code":"\nstop_not_found <- function(path) {\n  abort(\n    .subclass = \"fs_error_not_found\",\n    path = path\n  )\n}\n#' @export\nconditionMessage.fs_error_not_found <- function(c) {\n  glue::glue_data(c, \"'{path}' not found\")\n}\nstop_not_found(\"a.csv\")\n#> Error: 'a.csv' not found"},{"path":"err-constructor.html","id":"how-do-i-test","chapter":"28 Error constructors","heading":"28.4 How do I test?","text":"","code":"\nlibrary(testthat)\n#> \n#> Attaching package: 'testthat'\n#> The following objects are masked from 'package:rlang':\n#> \n#>     is_false, is_null, is_true"},{"path":"err-constructor.html","id":"test-the-constructor","chapter":"28 Error constructors","heading":"28.4.1 Test the constructor","text":"Firstly, test error constructor. primary goal test ensure error constructor generates message useful humans, can automate. means can use unit test (desired output known) instead need use regression test, can ensure message change unexpectedly. reason best approach usually use verify_output(), e.g.:useful pull requests verify_output() generates complete error messages text file can easily read reviewed.error multiple arguments, conditionMessage() method contains statements, generally attempt cover test case.","code":"\ntest_that(\"stop_not_found() generates useful error message\", {\n  verify_output(test_path(\"test-stop-not-found.txt\"), {\n    stop_not_found(\"a.csv\")\n  })\n})"},{"path":"err-constructor.html","id":"test-usage","chapter":"28 Error constructors","heading":"28.4.2 Test usage","text":"Now error constructor, ’ll need slightly change test functions use error constructor. example, take imaginary example reading file single string:Previously, might written:, now see, testthat gives warning suggests need use class argument instead:less fragile can now change error message without worry breaking existing tests.also want check components error object, note expect_error() returns :don’t think level testing generally important, use error generation code complex conditions, identified bug.","code":"\nread_lines <- function(x) {\n  if (!file.exists(x)) {\n    stop_not_found(x)\n  }\n  paste0(readLines(x), collapse = \"\\n\")\n}\nexpect_error(read_lines(\"missing-file.txt\"), \"not found\")\nexpect_error(read_lines(\"missing-file.txt\"), class = \"fs_error_not_found\")\ncnd <- expect_error(read_lines(\"missing-file.txt\"), class = \"fs_error_not_found\")\nexpect_equal(cnd$path, \"missing-file.txt\")"},{"path":"err-constructor.html","id":"error-hierarchies","chapter":"28 Error constructors","heading":"28.5 Error hierarchies","text":"start writing error constructors, may notice starting share code errors form natural hierarchy. take advantage hierarchy reduce amount code need write, can make errors subclassable adding ... class arguments:subclasses can call constructor, problem becomes one S3 class design. currently little experience , use caution.","code":"\nstop_not_found <- function(path, ..., class = character()) {\n  abort(\n    .subclass = c(class, \"fs_error_not_found\"),\n    path = path\n  )\n}"},{"path":"changes-multivers.html","id":"changes-multivers","chapter":"29 Work with multiple dependency versions","heading":"29 Work with multiple dependency versions","text":"","code":""},{"path":"changes-multivers.html","id":"whats-the-pattern-11","chapter":"29 Work with multiple dependency versions","heading":"29.1 What’s the pattern?","text":"ideal world, dependency package changes interface, want package work versions. work two significant advantages:CRAN submission process decoupled. package works \ndevelopment version dependency, ’ll need carefully coordinate \nCRAN submission dependencies CRAN submission. package works\nversions, can submit first, making life easier CRAN \nmaintainer dependency.CRAN submission process decoupled. package works \ndevelopment version dependency, ’ll need carefully coordinate \nCRAN submission dependencies CRAN submission. package works\nversions, can submit first, making life easier CRAN \nmaintainer dependency.User code less likely affected. package works \nlatest version dependency, user upgrades package, \ndependency also must update. Upgrading multiple packages likely \naffect user code updating single package.User code less likely affected. package works \nlatest version dependency, user upgrades package, \ndependency also must update. Upgrading multiple packages likely \naffect user code updating single package.pattern, ’ll learn write code designed work multiple versions dependency, ’ll adapt existing Travis configuration test ’ve got right.","code":""},{"path":"changes-multivers.html","id":"writing-code","chapter":"29 Work with multiple dependency versions","heading":"29.2 Writing code","text":"Sometimes easy way change code work old new versions package; can! However, cases, can’t, ’ll need statement runs different code new old versions package:(freshly written code uses functions don’t exist CRAN version generate R CMD check NOTE submit CRAN. one NOTEs can explain: just mention ’s needed forward/backward compatibility submission notes.)recommend always pulling check function logic lives one place. make much easier pull ’s longer needed, provides good place document ’s needed.three basic approaches implement dependency_has_new_interface():Check version package. recommended cases,\nrequires dependency author use specific version convention.Check version package. recommended cases,\nrequires dependency author use specific version convention.Check existence function.Check existence function.Check specific argument value, otherwise detect interface\nchanged.Check specific argument value, otherwise detect interface\nchanged.","code":"\nif (dependency_has_new_interface()) {\n  # freshly written code that works with in-development dependency\n} else {\n  # existing code that works with the currently released dependency\n}"},{"path":"changes-multivers.html","id":"case-study-tidyr","chapter":"29 Work with multiple dependency versions","heading":"29.2.1 Case study: tidyr","text":"make problem concrete can show real code, lets imagine package uses tidyr::nest(). tidyr::nest() changed substantially 0.8.3 1.0.0, need write code like :(described , submitted CRAN generate note missing tidyr::nest_legacy() can explained submission comments.)implement tidyr_new_interface(), need think three versions tidyr:0.8.3: version currently CRAN old interface.0.8.3: version currently CRAN old interface.0.8.99.9000: development version new interface. usualy,\nfourth component >= 9000 indicate ’s development\nversion. Note, however, patch version 99; indicates \nrelease includes breaking changes.0.8.99.9000: development version new interface. usualy,\nfourth component >= 9000 indicate ’s development\nversion. Note, however, patch version 99; indicates \nrelease includes breaking changes.1.0.0: future CRAN version; version submitted\nCRAN.1.0.0: future CRAN version; version submitted\nCRAN.main question write tidyr_new_interface(). three options:Check version greater development version:\n\ntidyr_new_interface <- function() {\n  packageVersion(\"tidyr\") > \"0.8.99\"\n}\ntechnique works tidyr uses convention \ndevelopment version backward incompatible functions contain 99\nthird (patch) component.Check version greater development version:technique works tidyr uses convention \ndevelopment version backward incompatible functions contain 99\nthird (patch) component.tidyr didn’t adopt naming convention, test \nexistence unnest_legacy().\n\ntidyr_new_interface1 <- function() {\n  exists(\"unnest_legacy\", asNamespace(\"tidyr\"))\n}tidyr didn’t adopt naming convention, test \nexistence unnest_legacy().inteface change subtle, might think \ncreatively. package uses lifecycle\nsystem, one approach test presence deprecated()\nfunction arguments:\n\ntidyr_new_interface2 <- function() {\n  identical(formals(tidyr::nest)$.key, quote(deprecated()))\n}inteface change subtle, might think \ncreatively. package uses lifecycle\nsystem, one approach test presence deprecated()\nfunction arguments:approaches reaosnably fast, ’s unlikely ’ll impact performance unless called tight loop.need use packageVersion() inside performance sensitive function, recommend caching result .onLoad() (, convention, lives zzz.R). ways ; following block shows one approach matches function interface used :","code":"\nif (tidyr_new_interface()) {\n  out <- tidyr::nest_legacy(df, x, y, z)\n} else {\n  out <- tidyr::nest(df, c(x, y, z))\n}\ntidyr_new_interface <- function() {\n  packageVersion(\"tidyr\") > \"0.8.99\"\n}\ntidyr_new_interface1 <- function() {\n  exists(\"unnest_legacy\", asNamespace(\"tidyr\"))\n}\ntidyr_new_interface2 <- function() {\n  identical(formals(tidyr::nest)$.key, quote(deprecated()))\n}\nbench::mark(\n  version = tidyr_new_interface(),\n  exists =  tidyr_new_interface1(),\n  formals = tidyr_new_interface2() \n)[1:5]\n#> # A tibble: 3 × 5\n#>   expression      min   median `itr/sec` mem_alloc\n#>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>\n#> 1 version     728.9µs  888.4µs     1074.    3.82KB\n#> 2 exists        3.1µs    4.1µs   198150.   17.34MB\n#> 3 formals       1.3µs    1.6µs   438516.        0B\ntidyr_new_interface <- function() FALSE\n.onLoad <- function(...) {\n  if (utils::packageVersion(\"tidyr\") > \"0.8.2\") {\n    tidyr_new_interface <<- function() TRUE\n  }\n}"},{"path":"changes-multivers.html","id":"testing-with-multiple-package-versions","chapter":"29 Work with multiple dependency versions","heading":"29.3 Testing with multiple package versions","text":"’s good practice test old new versions code, challenging can’t sets tests R session. easiest way make sure versions work stay working use Travis.dependency released, can manually install development version using remotes::install_github():’s generally important check code continues work older version package, want can use remotes::install_version():","code":"matrix:\n  include:\n  - r: release\n    name: tidyr-devel\n    before_script: Rscript -e \"remotes::install_github('tidyverse/tidyr')\"matrix:\n  include:\n  - r: release\n    name: tidyr-0.8\n    before_script: Rscript -e \"remotes::install_version('tidyr', '0.8.3')\""},{"path":"changes-multivers.html","id":"using-only-the-new-version","chapter":"29 Work with multiple dependency versions","heading":"29.4 Using only the new version","text":"point future, ’ll decide old version package longer widely used want simplify package depending new version. three steps:DESCRIPTION, bump required version dependency.DESCRIPTION, bump required version dependency.Search dependency_has_new_interface(); remove function defintion\nuses (retaining code used new version).Search dependency_has_new_interface(); remove function defintion\nuses (retaining code used new version).Remove additional build .travis.yml.Remove additional build .travis.yml.","code":""},{"path":"side-effect-soup.html","id":"side-effect-soup","chapter":"30 Side-effect soup","heading":"30 Side-effect soup","text":"Side-effect soup occurs mix side-effects regular computation within function.","code":""},{"path":"side-effect-soup.html","id":"what-is-a-side-effect","chapter":"30 Side-effect soup","heading":"30.1 What is a side-effect?","text":"two main types side-effect:give feedback user.change global state.","code":""},{"path":"side-effect-soup.html","id":"user-feedback","chapter":"30 Side-effect soup","heading":"30.1.1 User feedback","text":"Signalling condition, message(), warning(), stop().Signalling condition, message(), warning(), stop().Printing console cat().Printing console cat().Drawing current graphics device base graphics grid.Drawing current graphics device base graphics grid.","code":""},{"path":"side-effect-soup.html","id":"global-state","chapter":"30 Side-effect soup","heading":"30.1.2 Global state","text":"Creating (modifying) existing binding <-.Creating (modifying) existing binding <-.Modifying search path attaching package library().Modifying search path attaching package library().Changing working directory setwd().Changing working directory setwd().Modifying file disk (e.g.) write.csv().Modifying file disk (e.g.) write.csv().Changing global option options() base graphics parameter \ngpar().Changing global option options() base graphics parameter \ngpar().Setting random seed set.seed()Setting random seed set.seed()Installing package.Installing package.Changing environment variables Sys.setenv(), indirectly via \nfunction like Sys.setlocale().Changing environment variables Sys.setenv(), indirectly via \nfunction like Sys.setlocale().Modifying variable enclosing environment assign() <<-.Modifying variable enclosing environment assign() <<-.Modifying object reference semantics (like R6 data.table).Modifying object reference semantics (like R6 data.table).esoteric side-effects include:Detaching package search path detach().Detaching package search path detach().Changing library path, R looks packages, .libPaths()Changing library path, R looks packages, .libPaths()Changing active graphics device (e.g.) png() dev.().Changing active graphics device (e.g.) png() dev.().Registering S4 class, method, generic methods::setGeneric().Registering S4 class, method, generic methods::setGeneric().Modifying internal .Random.seedModifying internal .Random.seed","code":""},{"path":"side-effect-soup.html","id":"what-are-some-examples-14","chapter":"30 Side-effect soup","heading":"30.2 What are some examples?","text":"summary linear model includes p-value overall\nregression. value computed summary printed:\ncan see can’t touch .\n\nmod <- lm(mpg ~ wt, data = mtcars)\nsummary(mod)\n#> \n#> Call:\n#> lm(formula = mpg ~ wt, data = mtcars)\n#> \n#> Residuals:\n#>     Min      1Q  Median      3Q     Max \n#> -4.5432 -2.3647 -0.1252  1.4096  6.8727 \n#> \n#> Coefficients:\n#>             Estimate Std. Error t value Pr(>|t|)    \n#> (Intercept)  37.2851     1.8776  19.858  < 2e-16 ***\n#> wt           -5.3445     0.5591  -9.559 1.29e-10 ***\n#> ---\n#> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n#> \n#> Residual standard error: 3.046 30 degrees freedom\n#> Multiple R-squared:  0.7528, Adjusted R-squared:  0.7446 \n#> F-statistic: 91.38 1 30 DF,  p-value: 1.294e-10The summary linear model includes p-value overall\nregression. value computed summary printed:\ncan see can’t touch .","code":"\nmod <- lm(mpg ~ wt, data = mtcars)\nsummary(mod)\n#> \n#> Call:\n#> lm(formula = mpg ~ wt, data = mtcars)\n#> \n#> Residuals:\n#>     Min      1Q  Median      3Q     Max \n#> -4.5432 -2.3647 -0.1252  1.4096  6.8727 \n#> \n#> Coefficients:\n#>             Estimate Std. Error t value Pr(>|t|)    \n#> (Intercept)  37.2851     1.8776  19.858  < 2e-16 ***\n#> wt           -5.3445     0.5591  -9.559 1.29e-10 ***\n#> ---\n#> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n#> \n#> Residual standard error: 3.046 on 30 degrees of freedom\n#> Multiple R-squared:  0.7528, Adjusted R-squared:  0.7446 \n#> F-statistic: 91.38 on 1 and 30 DF,  p-value: 1.294e-10"},{"path":"side-effect-soup.html","id":"why-is-it-bad","chapter":"30 Side-effect soup","heading":"30.3 Why is it bad?","text":"Side-effect soup bad :function computation side-effects, can \nchallenging extract results computation.function computation side-effects, can \nchallenging extract results computation.Makes code harder analyse may non-local effects.\nTake code:\n\nx <- 1\ny <- compute(x)\nz <- calculate(x, y)\n\ndf <- data.frame(x = \"x\")\ncompute() calculate() don’t side-effects can\npredict df . compute() \noptions(stringsAsFactors = FALSE) df now contain \ncharacter vector rather factor.Makes code harder analyse may non-local effects.\nTake code:compute() calculate() don’t side-effects can\npredict df . compute() \noptions(stringsAsFactors = FALSE) df now contain \ncharacter vector rather factor.Side-effect soup increases cognitive load function used deliberately, especially cautious combining techniques increase cognitive load like tidy-evaluation type-instability.","code":"\nx <- 1\ny <- compute(x)\nz <- calculate(x, y)\n\ndf <- data.frame(x = \"x\")"},{"path":"side-effect-soup.html","id":"how-avoid-it","chapter":"30 Side-effect soup","heading":"30.4 How avoid it?","text":"","code":""},{"path":"side-effect-soup.html","id":"localise-side-effects","chapter":"30 Side-effect soup","heading":"30.4.1 Localise side-effects","text":"Constrain side-effects small scope possible, clean automatically avoid side-effects. withr","code":""},{"path":"side-effect-soup.html","id":"extract-side-effects","chapter":"30 Side-effect soup","heading":"30.4.2 Extract side-effects","text":"’s side-effects bad, much mixing non-side-effect code.Put function specifically focussed side-effect.function called primarily side-effects, return primary data structure (first argument), invisibly. allows call mid-pipe side-effects allow primary data continue flowing pipe.","code":""},{"path":"side-effect-soup.html","id":"make-side-effects-noisy","chapter":"30 Side-effect soup","heading":"30.4.3 Make side-effects noisy","text":"Primary purpose entire package side-effects: modifying files disk support package project development. usethis functions also designed noisy: well ’s job, usethis function tells ’s .usethis functions building blocks complex tasks.","code":""},{"path":"side-effect-soup.html","id":"provide-an-argument-to-suppress","chapter":"30 Side-effect soup","heading":"30.4.4 Provide an argument to suppress","text":"’ve probably used base::hist() ’s side-effect drawing histogram:might know hist() also returns result computation. call plot = FALSE simply return results computation:good approach retro-fitting older functions making minimal API changes. However, think dilutes function used plotting computing best avoided newer code.","code":"\nx <- rnorm(1e5)\nhist(x)\nxhist <- hist(x, plot = FALSE)\nstr(xhist)\n#> List of 6\n#>  $ breaks  : num [1:20] -4.5 -4 -3.5 -3 -2.5 -2 -1.5 -1 -0.5 0 ...\n#>  $ counts  : int [1:19] 1 17 103 475 1576 4498 9122 15079 19122 19120 ...\n#>  $ density : num [1:19] 0.00002 0.00034 0.00206 0.0095 0.03152 ...\n#>  $ mids    : num [1:19] -4.25 -3.75 -3.25 -2.75 -2.25 -1.75 -1.25 -0.75 -0.25 0.25 ...\n#>  $ xname   : chr \"x\"\n#>  $ equidist: logi TRUE\n#>  - attr(*, \"class\")= chr \"histogram\""},{"path":"side-effect-soup.html","id":"use-the-print-method","chapter":"30 Side-effect soup","heading":"30.4.5 Use the print() method","text":"alternative approach always return computation, instead perform output print() method.course ggplot2 isn’t perfect: creates object specifies plot, ’s easy way extract underlying computation ’ve used geom_smooth() add lines best fit, ’s way extract values. , can see results, can’t touch , frustrating!","code":""},{"path":"side-effect-soup.html","id":"make-easy-to-undo","chapter":"30 Side-effect soup","heading":"30.4.6 Make easy to undo","text":"techniques fail, least make side-effect easy undo. use technique make sure function returns previous values, can take ’s input.options() par() work. obviously can’t eliminate functions complete purpose global changes! designed away can easily undo operation, making possible apply local basis.two key ideas make functions easy undo:invisibly return\nprevious values list:\n\noptions(my_option = 1)\nold <- options(my_option = 2)\nstr(old)\n#> List 1\n#>  $ my_option: num 1They invisibly return\nprevious values list:Instead n named arguments, can take single named list:\n\nold <- options(list(my_option1 = 1, my_option2 = 2))\n(wouldn’t recommend copying technique, ’d instead recommend\nalways taking single named list. makes function \nsingle way call makes easy extend API \nfuture, discussed Chapter 19)Instead n named arguments, can take single named list:(wouldn’t recommend copying technique, ’d instead recommend\nalways taking single named list. makes function \nsingle way call makes easy extend API \nfuture, discussed Chapter 19)Together, means easily can set options temporarily.:temporarily setting options function, always restore previous values using .exit(): ensures code run regardless function exits.","code":"\noptions(my_option = 1)\nold <- options(my_option = 2)\nstr(old)\n#> List of 1\n#>  $ my_option: num 1\nold <- options(list(my_option1 = 1, my_option2 = 2))\ngetOption(\"my_option1\")\n#> [1] 1\n\nold <- options(my_option1 = 10)\ngetOption(\"my_option1\")\n#> [1] 10\noptions(old)\n\ngetOption(\"my_option1\")\n#> [1] 1"},{"path":"side-effect-soup.html","id":"package-considerations","chapter":"30 Side-effect soup","heading":"30.5 Package considerations","text":"Code package executed build-time..e. :mac windows, record CRAN built binary. linux, package installed.Beware copying functions packages:Version barfy might different run-time build-time.Introduces build-time dependency.https://github.com/r-lib/devtools/issues/1788","code":"\nx <- Sys.time()\nfoofy <- barfy::foofy"},{"path":"spooky-action.html","id":"spooky-action","chapter":"31 Spooky action","heading":"31 Spooky action","text":"","code":""},{"path":"spooky-action.html","id":"whats-the-problem-5","chapter":"31 Spooky action","heading":"31.1 What’s the problem?","text":"limits function script can . call draw_plot() source(\"analyse-data.R\"), discover variables global environment deleted, 1000 new files created desktop. actions surprising, generally expect impact function (script) limited possible. Collectively, call side-effects “spooky actions” connection action (calling function sourcing script) result (deleting objects upgrading packages) surprising. ’s like flipping light-switch discovering shower starts running, poltergeist rearranges contents kitchen cupboards ’re looking.Deleting variables creating files desktop obviously surprising even ’ve just started using R. actions less obviously destructive, start become surprising mental model R matures. include actions like:Attaching packages library(). example, ggplot2::geom_map() used\ncall library(maps) order make map data available function.\nseems harmless, using purrr, break map()\nmap() now refer maps::map() rather purrr::map().\nfunctions different packages can name, attaching\npackage can change behaviour existing code.Attaching packages library(). example, ggplot2::geom_map() used\ncall library(maps) order make map data available function.\nseems harmless, using purrr, break map()\nmap() now refer maps::map() rather purrr::map().\nfunctions different packages can name, attaching\npackage can change behaviour existing code.Installing packages install.packages(). script needs dplyr \nwork, ’s installed, seem polite install behalf \nuser. installing new package can upgrade existing packages, might\nbreak code projects. Install package potentially destructive\noperation done care.Installing packages install.packages(). script needs dplyr \nwork, ’s installed, seem polite install behalf \nuser. installing new package can upgrade existing packages, might\nbreak code projects. Install package potentially destructive\noperation done care.Deleting objects global environment rm(list = ls()).\nmight seem like good way reset environment \nscript can run cleanly. someone else source()s script, \ndelete objects might important . (course, ’d hope \nobjects easily recreated another script, \nalways case).Deleting objects global environment rm(list = ls()).\nmight seem like good way reset environment \nscript can run cleanly. someone else source()s script, \ndelete objects might important . (course, ’d hope \nobjects easily recreated another script, \nalways case).R doesn’t constrain potential scope functions scripts, . avoiding actions, create code less surprising R users. first, might seem like tedious busywork. might find spooky action convenient moment, might convince ’s necessary good idea. share code people run code shared you5, ’ll find spooky action get surprising frustrating.","code":""},{"path":"spooky-action.html","id":"what-precisely-is-a-spooky-action","chapter":"31 Spooky action","heading":"31.2 What precisely is a spooky action?","text":"can make notion spooky action precise thinking trees. Code affect tree beneath lives, action reaches , across, tree spooky action.two important types trees consider:tree formed files directories.\nscript read write directories beneath \ndirectory lives. explains shouldn’t install packages\n(package library usually lives elsewhere), also explains\nshouldn’t create files desktop.\nrule can relaxed two small ways. Firstly, script\nlives project, ’s ok read write anywhere \nproject (.e. file R/ can read data-raw/ write \ndata/). Secondly, ’s always ok write session specific\ntemporary directory, tempdir(). directory automatically deleted\nR closes, lasting effects.tree formed files directories.\nscript read write directories beneath \ndirectory lives. explains shouldn’t install packages\n(package library usually lives elsewhere), also explains\nshouldn’t create files desktop.rule can relaxed two small ways. Firstly, script\nlives project, ’s ok read write anywhere \nproject (.e. file R/ can read data-raw/ write \ndata/). Secondly, ’s always ok write session specific\ntemporary directory, tempdir(). directory automatically deleted\nR closes, lasting effects.tree environments created function calls.\nfunction create modify variables environment\nenvironments creates (typically calling functions).\nexplains shouldn’t attach packages (changes \nsearch path),\nshouldn’t delete variables rm(list = ls()),\nassign variables didn’t create <<-.tree environments created function calls.\nfunction create modify variables environment\nenvironments creates (typically calling functions).\nexplains shouldn’t attach packages (changes \nsearch path),\nshouldn’t delete variables rm(list = ls()),\nassign variables didn’t create <<-.","code":""},{"path":"spooky-action.html","id":"how-can-i-remediate-spooky-actions","chapter":"31 Spooky action","heading":"31.3 How can I remediate spooky actions?","text":"read cautions, still want proceed, three ways can make spooky action safe possible:Allow user control scope.Allow user control scope.Make action less spooky giving name clearly describes\n.Make action less spooky giving name clearly describes\n.Explicitly check user proceeding action.Explicitly check user proceeding action.Advertise ’s happening, action might still spooky,\nleast isn’t surprising.Advertise ’s happening, action might still spooky,\nleast isn’t surprising.","code":""},{"path":"spooky-action.html","id":"parameterise-the-action","chapter":"31 Spooky action","heading":"31.3.1 Parameterise the action","text":"first technique allow user control action occur. example, instead save_output_desktop(), write save_output(path), require user provide path.","code":""},{"path":"spooky-action.html","id":"advertise-the-action-with-a-clear-name","chapter":"31 Spooky action","heading":"31.3.2 Advertise the action with a clear name","text":"can’t parameterise action, make clear ’s going happen outside. fine function scripts actions outside usual trees long implicit name:’s ok <- modify global environment, one\njob, ’s obvious name (’ve learned <-, \nhappens early). Similarly, ’s ok save_output_to_desktop() \ncreate files desktop, copy_to_clipboard() copy text \nclipboard, action clear name.’s ok <- modify global environment, one\njob, ’s obvious name (’ve learned <-, \nhappens early). Similarly, ’s ok save_output_to_desktop() \ncreate files desktop, copy_to_clipboard() copy text \nclipboard, action clear name.’s fine install.packages() modify files outside current\nworking directory ’s designed specifically install packages.\nSimilarly, ’s ok source(\"class-setup.R\") install packages \nintent setup script get computer state \nsomeone else’s.’s fine install.packages() modify files outside current\nworking directory ’s designed specifically install packages.\nSimilarly, ’s ok source(\"class-setup.R\") install packages \nintent setup script get computer state \nsomeone else’s., ’s name function script really important. soon youNote ’s name ’s important - ’s fine install.packages() install packages, ’s ok soon ’s hidden behind even simple wrapper:","code":"\ncurrent_time <- function() {\n  if (!requireNamespace(\"lubridate\", quietly = TRUE)) {\n    install.packages(\"lubridate\")\n  }\n  lubridate::now()\n}\ncurrent_time()\n#> [1] \"2022-11-01 04:57:42 UTC\""},{"path":"spooky-action.html","id":"ask-for-confirmation","chapter":"31 Spooky action","heading":"31.3.3 Ask for confirmation","text":"can’t parameterise operation, need perform somewhere deep within cope, make sure confirm user performing action. code shows might installing package:Note use interactive() : user interactive setting (.e. code run Rscript) can get explicit confirmation, shouldn’t make changes. Also failures errors: ensures remainder function script run user doesn’t confirm.Ideally function also clearly describe consequences decision. example, nice know download significant amount data (since might want wait fast connection downloading 1 Gb data package), upgrade existing packages (since might break code).Writing code checks user requires care, ’s easy get details wrong. ’s ’s better prefer one prior techniques.","code":"\ninstall_if_needed <- function(package) {\n  if (requireNamespace(package, quietly = TRUE)) {\n    return(invisible(TRUE))\n  }\n  \n  if (!interactive()) {\n    stop(package, \" is not installed\", call. = FALSE)\n  }\n  \n  title <- paste0(package, \" is not installed. Do you wish to install now?\")\n  if (menu(c(\"Yes\", \"No\"), title = title) != 1) {\n    stop(\"Confirmation not received\", call. = FALSE)\n  }\n  \n  invisible(TRUE)\n}"},{"path":"spooky-action.html","id":"advertise-the-side-effects","chapter":"31 Spooky action","heading":"31.3.4 Advertise the side-effects","text":"can’t get explicit confirmation user, minimum clearly advertise happening. example, call install.packages() notifies :However, message work:says installing “package”, without specifying package (\ncalled inside another function won’t informative).says installing “package”, without specifying package (\ncalled inside another function won’t informative).doesn’t notify dependencies ’s also going update.doesn’t notify dependencies ’s also going update.notifies url ’s downloading , don’t care ,\nnotifies size ’s finished downloading,\ntime late stop .notifies url ’s downloading , don’t care ,\nnotifies size ’s finished downloading,\ntime late stop .instead write something like :’ll come back issue informing user …","code":"\ninstall.packages(\"dplyr\")\n#> Installing package into ‘/Users/hadley/R’\n#> (as ‘lib’ is unspecified)\n#> Trying URL 'https://cran.rstudio.com/bin/macosx/el-capitan/contrib/3.5/dplyr_0.8.0.1.tgz'\n#> Content type 'application/x-gzip' length 6587031 bytes (6.3 MB)\n#> ==================================================\n#> downloaded 6.3 MB\ninstall.packages(\"dplyr\")\n#> Installing package dplyr to `/Users/hadley/R`\n#> Also installing 3 dependencies: glue, rlang, R6"},{"path":"spooky-action.html","id":"case-studies","chapter":"31 Spooky action","heading":"31.4 Case studies","text":"","code":""},{"path":"spooky-action.html","id":"save-and-load","chapter":"31 Spooky action","heading":"31.4.1 save() and load()","text":"load() spooky action modifies variables current environment:can make less spooky supplying verbose = TRUE. learn also loaded y object:(ideal world verbose = TRUE default)generally, ’d avoid save() load() altogether, instead use saveRDS() readRDS(), read write individual R objects individual R files work <-. eliminates spooky action:(readr provides readr::read_rds() readr::write_rds() inconsistent naming conventions bother like bother .)","code":"\nx <- 1\nload(\"spooky-action.rds\")\nx\n#> [1] 10\nload(\"spooky-action.rds\", verbose = TRUE)\n#> Loading objects:\n#>   x\n#>   y\ny\n#> [1] 100\nsaveRDS(x, \"x.rds\")\nx <- readRDS(\"x.rds\")\nunlink(\"x.rds\")"},{"path":"spooky-action.html","id":"usethis","chapter":"31 Spooky action","heading":"31.4.2 usethis","text":"usethis package designed support process developing package R code. automates many tedious setup steps providing function like use_r() use_test(). Many usethis functions modify DESCRIPTION create files. usethis makes actions pedestrian possible :Making clear entire package designed purpose \ncreating modifying files, purpose function clearly\nencoded named.Making clear entire package designed purpose \ncreating modifying files, purpose function clearly\nencoded named.potential risky operation, e.g. overwriting existing file, usethis\nexplicitly asks confirmation user. make harder “click”\nprompts without reading , usethis uses random prompts \nrandom ordering.\n\nusethis::ui_yeah(\"want proceed?\")\n#> want proceed?\n#> \n#> 1: Absolutely \n#> 2: now\n#> 3: agree\nusethis also works concert git make sure change captured\nway can easily undone.potential risky operation, e.g. overwriting existing file, usethis\nexplicitly asks confirmation user. make harder “click”\nprompts without reading , usethis uses random prompts \nrandom ordering.usethis also works concert git make sure change captured\nway can easily undone.call , every usethis function describes \n:\n\nusethis::create_package(\"mypackage\", open = FALSE)\n#> ✔ Creating 'mypackage'\n#> ✔ Setting active project 'mypackage'\n#> ✔ Creating 'R/'\n#> ✔ Writing 'DESCRIPTION'\n#> ✔ Writing 'NAMESPACE'\n#> ✔ Writing 'mypackage.Rproj'\n#> ✔ Adding '.Rproj.user' '.gitignore'\n#> ✔ Adding '^mypackage\\\\.Rproj$', '^\\\\.Rproj\\\\.user$' '.Rbuildignore'\nimportant, ’s clear impactful \nmany functions produce enough output reading seems\nonerous generally people don’t read .call , every usethis function describes \n:important, ’s clear impactful \nmany functions produce enough output reading seems\nonerous generally people don’t read .","code":"\nusethis::ui_yeah(\"Do you want to proceed?\")\n#> Do you want to proceed?\n#> \n#> 1: Absolutely not\n#> 2: Not now\n#> 3: I agree\nusethis::create_package(\"mypackage\", open = FALSE)\n#> ✔ Creating 'mypackage'\n#> ✔ Setting active project to 'mypackage'\n#> ✔ Creating 'R/'\n#> ✔ Writing 'DESCRIPTION'\n#> ✔ Writing 'NAMESPACE'\n#> ✔ Writing 'mypackage.Rproj'\n#> ✔ Adding '.Rproj.user' to '.gitignore'\n#> ✔ Adding '^mypackage\\\\.Rproj$', '^\\\\.Rproj\\\\.user$' to '.Rbuildignore'"},{"path":"spooky-action.html","id":"section","chapter":"31 Spooky action","heading":"31.4.3 <<-","text":"haven’t heard <<-, super-assignment operator, , feel free skip section ’s advanced technique relatively limited applications. ’re important context functionals, can read Advanced R.<<- safe use modify variable environment control. example, following code creates function counts number times called. use <<- safe affects environment created make_counter(), external environment.common use <<- break one limitations map()6 use like loop iteratively modify input. example, imagine want compute cumulative sum. ’s straightforward write loop:simple transformation use map() doesn’t work:modification happening inside function, R creates copy (called copy--modify principle). Instead need use <<- reach outside function modify outer :use <<- spooky action ’re reaching tree environments modify object created outside function. case, however, ’s point using map(): point functions restrict can compared loop code easier understand. R data science examples loops rewritten map(), shouldn’t .Note still wrap code function eliminate spooky action:eliminates spooky action ’s now modifying object function “owns”, still wouldn’t recommend , use map() <<- increases complexity gain compared use loop.","code":"\nmake_counter <- function() {\n  i <- 0\n  function() {\n    i <<- i + 1\n    i\n  }\n}\nc1 <- make_counter()\nc2 <- make_counter()\nc1()\n#> [1] 1\nc1()\n#> [1] 2\nc2()\n#> [1] 1\nx <- rpois(10, 10)\n\nout <- numeric(length(x))\nfor (i in seq_along(x)) {\n  if (i == 1) {\n    out[[i]] <- x[[i]]\n  } else {\n    out[[i]] <- x[[i]] + out[[i - 1]]\n  }\n}\n\nrbind(x, out)\n#>     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n#> x      8    4   11   11   13   15   10   11   11    19\n#> out    8   12   23   34   47   62   72   83   94   113\nlibrary(purrr)\nout <- numeric(length(x))\nmap_dbl(seq_along(x), function(i) {\n  if (i == 1) {\n    out[[i]] <- x[[i]]\n  } else {\n    out[[i]] <- x[[i]] + out[[i - 1]]\n  }\n})\n#>  [1]  8  4 11 11 13 15 10 11 11 19\nmap_dbl(seq_along(x), function(i) {\n  if (i == 1) {\n    out[[i]] <<- x[[i]]\n  } else {\n    out[[i]] <<- x[[i]] + out[[i - 1]]\n  }\n})\n#>  [1]   8  12  23  34  47  62  72  83  94 113\ncumsum2 <- function(x) {\n  out <- numeric(length(x))\n  map_dbl(seq_along(x), function(i) {\n    if (i == 1) {\n      out[[i]] <<- x[[i]]\n    } else {\n      out[[i]] <<- x[[i]] + out[[i - 1]]\n    }\n  })\n  out\n}"},{"path":"spooky-action.html","id":"assign-in-a-for-loop","chapter":"31 Spooky action","heading":"31.4.4 assign() in a for loop","text":"’s uncommon people ask create multiple objects loop. example, maybe vector file names, want read file individual object. effort typically discover assign():main problem approach facilitate composition. example, imagine now wanted figure many rows data frames. Now need learn loop series objects, name object stored character vector. work, might discover get() write:approach necessarily bad itself7, tends lead high-friction path. Instead, learn little lists functional programming techniques (e.g. purrr), ’ll able write code like :obviously requires learn new tools - learning map() map_int() pay many situations learning assign() get(). can reuse map() friends many places, ’ll find get easier easier use time.certainly possible build tools purrr avoid learn assign() get() provide polished interface working character vectors containing object names. functions need reach tree environments, violate “spooky action” principle, thus believe best avoided.","code":"\npaths <- c(\"a.csv\", \"b.csv\", \"c.csv\")\nnames(paths) <- c(\"a\", \"b\", \"c\")\n\nfor (i in seq_along(paths)) {\n  assign(names(paths)[[i]], read.csv(paths[[i]]))\n}\nlengths <- numeric(length(names))\nfor (i in seq_along(paths)) {\n  lengths[[i]] <- nrow(get(names(paths)[[i]]))\n}\nlibrary(purrr)\n\nfiles <- map(paths, read.csv)\nlengths <- map_int(files, nrow)"},{"path":"glossary.html","id":"glossary","chapter":"A Glossary","heading":"A Glossary","text":"","code":""}]
