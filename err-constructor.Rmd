# Error constructors {#err-constructor}

```{r, include = FALSE}
source("common.R")
```

## What's the pattern?

Whenever you generate the same error message (or similar error messages) from different functions you should extract the repeated code into an __error constructor__. At this point you should also invest in createing a richer error object (aka classed condition), that makes it easier to test. 

(This is a new pattern that is currently used in few places in the tidyverse, but you should expect to see it in more and more packages in the future.)

## Error construction

An error constructor is very similar to an [S3 constructor](https://adv-r.hadley.nz/s3.html#s3-constructor), as its job is to extract out repeated code and generate a rich object that can easily be computed with. It should:

* Be called `stop_error_type()`.  Spend some time on the name as it is part of
  the exported interface of a function, so changing it later will require 
  work.

* Have one argument for each part of the error message that varies. Each
  argument is used in two ways: in a call to `glue::glue()` that generates
  an error message designed to be helpful to a human, and passed on to
  `rlang::abort()` so it is available for testing.

* Create and throw an error using `rlang::abort()` with a custom subclass
  of the form `pkgname_error_type` (i.e. it should add `pkgname_` prefix to
  the name of the function).

* If the error is subclassable, it should also have `...` and `class` arguments,
  in the same way an [S3 constructor](https://adv-r.hadley.nz/s3.html#s3-subclassing)
  does.

Generally these error constructors should be exported so that you can document them. Then in the documentation of the function that calls them, you can link to the documentation that gives the details of the error.

### Example

```{r}
stop_request_failed <- function(code, message, status) {
  message <- glue::glue(
    "HTTP error {code}\n",
    "  * message: {sq(message)}\n",
    "  * status: {sq(status)}"
  )
  
  # needed because httr doesn't export stop_request()
  class <- c("gargle_error_request_failed", paste0("http_error_", code))
  
  rlang::abort(
    message, 
    .subclass = class,
    message = message,
    status = status
  )
}
```

### How do I test?

Generally test in three ways:

*   That a function returns the correct error type. This is a safer replacement 
    for using text matching.

    ```{r, eval = FALSE}
    expect_error(foofy(1, 2), class = "pkgname_error_bad_input")
    ```

*   If you want to be more specific (either because the error conditions are
    complex or you have identified a bug that you want to test for), you
    should catch the error and then use `expect_equal()` to compare components.
    
    ```{r, eval = FALSE}
    cnd <- catch_cnd(foofy(1, 2))
    expect_s3_class(cnd, "pkgname_error_bad_input")
    expect_equal(cnd$a, "Blah")
    ```

*   That the error generates a user friendly error message. Since you can't 
    computationally test that an error message is understanable by a human,
    this should be a regression test. 
    
    Until testthat has [`expect_known_output()`](https://github.com/r-lib/testthat/issues/782)
    best option is to `catch_cnd()` and use `expect_known_output()`.
    
    ```{r, eval = FALSE}
    cnd <- catch_cnd(stop_my_function())
    expect_known_output(cnd, "test-stop-my-function-message.txt", print = TRUE)
    ```
