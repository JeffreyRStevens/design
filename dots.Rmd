# Dots

```{r, include = FALSE}
source("common.R")
```

```{r setup}
library(purrr)
```

The dots `...` are a powerful tool for R programming as they make it possible to pass along any number of additional arguments. They have three primary ues:

*   Passing on to another function. For example, `purrr::map()` uses
    `...` to pass additional arguments along to the function being mapped.
    In the following code, `na.rm` is an argument to `mean`, not to `map`:
  
    ```{r}
    mtcars %>% map_dbl(mean, na.rm = TRUE)
    ```
  
*   Creating data structures. For example, `list()` and `data.frame()` take 
    `...` to allow you to create new data structures with named inputs:
  
    ```{r}
    list(x = 1, y = 2:5)
    data.frame(x = 1, y = 2)
    ```
  
*   Allow S3 methods to take additional arguments. As a general rule, the methods
    of S3 generics must have the same argument as the parent. But what if you
    need an argument that only applies to some data types? For example, 
    the `print()` method for factors has an `max.levels` argument, which doesn't
    apply to other data types. This works because the `print()` generic has 
    `...`.

These three use cases are important, and `...` makes their expression convenient. But `...` comes with a major downside: if the function call is misspecified, `...` can easily swallow arguments with out warning, leading to functions that silently return incorrect values.

For example, take the following two calls that compute a mean and weighted mean:

```{r}
mean(1, 2, 3, 4)
weighted.mean(1:3, wt = c(0, 0, 1))
```

These two calls return silently incorrect results because `...` swallow up the mispecified function arguments. Compare the inputs and outputs when we correctly specify the calls:

```{r}
mean(c(1, 2, 3, 4))
weighted.mean(1:3, w = c(0, 0, 1))
```

This chapter describes how you can use `...` as safely as possible, minimising the chances of bad matches. There are two general rules:

* Put `...` as far to the left in the argument list as possible.
* Use a function from the ellipsis package to warn about bad matches.

## Passing `...` to another function

Place as far to the left as possible to force users to name arguments. Should come between data and details arguments. You can not rely on partial matching after ..., so this forces user to fully spell out argument names (which is generally good practice).

### Functional programming

The primary purpose of the function is to call another function repeatedly. So all arguments get `.` prefix.

Pass on to another function (particularly in functional programming).
`purrr::map()` (or `lapply()`) is basically a wrapper around a for loop:

```{r}
map <- function(.x, .f, ...) {
  out <- vector(length(.x), "list")
  for (i in seq_along(.x)) {
    out[[i]] <- .f(.x[[i]], ...)
  }
  out
}
```

Here `...` is useful because we don't know what the arguments to `.f` are.

Using `...` means that 

For example `purrr::map(x, f)` calls `f()` once for each element of `x`
(i.e. it returns `list(f(x[[1]]), f(x[[2]]), f(x[[3]])))`. What happens if
you want to pass arguments along to `f()`? You can use any function, so
there's no way for `map()` to possibly know the full set of arguments.


Have to assume that `.f` will report on incorrectly supplied arguments.

### Saving typing

```{r}
points.default
```

```{r}
sort.default
```

Might be technically knowable at one point in time, but makes it possible to decouple.

Make sure the funtion that eventually gets called checks for unnused dots. 

`stringr::str_sort()` -> `stringi::stri_opts_collator()`

`install_github()` -> `install.packages()` -> `download.file()`. https://github.com/r-lib/ellipsis/issues/10#issuecomment-469915847. If not, call `ellipsis::check_used_dots()`.


### Tidy evaluation

Pass the dots pattern. 

## Data-structure creation

No data arguments, details arguments should come after `...` and have `.` prefix.

Use `list2()` instead of list.

If you want something simpler of guaranteed type, you have to use `vctrs::vec_c(.ptype = integer())`. If you don't want a vctrs dependency, you'll need `c()` + an error if it's the incorrect type.

### Avoid ... just to avoid `c()` {#vectors-not-dots}

Only use this pattern when the primary intent of the function is to create data. Avoid using it if you're all your doing is eliminating a call to `...`, and reserve it for frequently used data creation functions where eliminating three keystrokes will pay off over time.

i.e. `forcats::fct_relevel()`, `sum()`, `order()`

It make future API changes quite difficult, and as above, can make misspellings give silently wrong outputs. If you do use it for this purpose make sure to call `ellipsis::check_dots_unnamed()` to ensure that no named arguments have been accidentally passed to `...`. 

### Trailing commas

Note that rlang and vctrs functions allow you to omit the trailing comma:

```{r, error = TRUE}
list(1, 2, )
rlang::list2(1, 2, )
```

This is very useful when constructing larger data structures, because you can leave a trailing comma on every line. This makes it easier to rearrange the contents, and to add new.

## S3 methods

Use `ellipsis::check_dots_used()`

Ensure arguments to the right of the dots (i.e. details arguments) are prefixed with `.`. (The dots prefix is not considered part of the argument name so it's ok to have some functions with argument `f` and some with `.f`.)

Example of why it has to be this complicated (because you don't know what arguments the method of a subclass will take.)

Base R exceptions

```{r, eval = FALSE}
median(x, na.rm = FALSE, ...)
mean(x, trim = 0, na.rm = FALSE, ...)
```

Both of these are suoptimal, because if you accidentally supply a sequence of values rather than a wrapper value, (as you might expect from `sum()` and `prod()`.), the named arguments will silently swallow the extra values. This is probably not a general rule, but I think it helps to force people to fully spell out the detail argument names. Bigger problem is mismatch of API design between `

```{r}
args(sum)
args(mean)
args(getS3method("mean", "default"))
args(weighted.mean)
args(getS3method("weighted.mean", "default"))
```

`dplyr::filter()` as example of custom error. `dplyr::group_by()` as example of bad name `add` (not `.add`), and `.drp = TRUE` does not give an error. It will create a column, but you might miss that. You could throw an error if any column names starts with a `.`, but that seems overly restrictive, since it's otherwise a good column name. `:=` as a general way out.

What about `mutate()`? 

## Multiple dots

Have multiple lists and use `rlang::exec()` (or `base::do.call()`)
