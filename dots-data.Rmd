# Making data with ...

```{r, include = FALSE}
source("common.R")
library(tidyverse)
```

A number of functions take `...` to save the user from having to create a single vector themselves:

```{r}
sum(c(1, 1, 1))
# can be shortened to:
sum(1, 1, 1)

f <- factor(c("a", "b", "c", "d"), levels = c("b", "c", "d", "a"))
f
fct_relevel(f, c("b", "a"))
# can be shortened to:
fct_relevel(f, "b", "a")
```

In general, I think it is best to avoid using `...` in this way. It has a relatively small benefit, only reducing typing by three letters `c()`, but has a number of costs:

*   It can give the misleading impression that other functions in the same
    family work the same way. For example, if you're internalised how `sum()`
    works, you might predict that `mean()` works the same way, but it does
    not:
  
    ```{r}
    mean(c(1, 2, 3))
    mean(1, 2, 3)
    ```
    
    (See "data-dots-details", Chapter \@ref(dots-lhs), to learn why this
    doesn't give an error message).

*   It makes it harder to change the interface if you realise that the function
    should take other types of input. For example, `fct_relevel()` can also be
    called with a function:
    
    ```{r}
    fct_relevel(f, sort)
    ```
    
    If `fct_relevel()` took a single argument, it would be easy to condition
    based on the type of this argument: do one thing if it's a character
    vector, and another thing if it's a function. However, because
    `fct_relevel()` uses dots, the implementation needs to be more complicated:

    ```{r}
    old_levels <- levels(f)
    if (dots_n(...) == 1L && (is.function(..1) || is_formula(..1))) {
      fun <- as_function(..1)
      first_levels <- fun(old_levels)
    } else {
      first_levels <- chr(...)
    }
    ```

## Amelioration

If you do feel that the tradeoff is worth it (i.e. it's an extremely frequently used function and the savings over time will be considerable), you need to take some steps to minimise the downsides.

This is easiest if you're constructing a vector that shouldn't have names. In this case, you can call `ellipsis::check_dots_unnamed()` to ensure that no named arguments have been accidentally passed to `...`. This protects you against the following undesirable behaviour of `sum()`:

```{r, error = TRUE}
sum(1, 1, 1, na.omit = TRUE)

safe_sum <- function(..., na.rm = TRUE) {
  ellipsis::check_dots_unnamed()
  sum(c(...), na.rm = na.rm)
}
safe_sum(1, 1, 1, na.omit = TRUE)
```

If you want your vector to have names, the problem is harder, and there's relatively little that you can. You'll need to ensure that all other arguments get a `.` prefix (to minimise chances of a mismatch) and then think carefully about how you might detect problems by thinking about the expect type of `c(...)`. As far as I know, there are no general techniques, and you'll have to think about the problem on a case-by-case basis.

## Selecting variables

A number of funtions in the tidyverse use `...` in a similar way for selecting variables. For example, `tidyr::fill()` lets you fill in missing values based on the previous row:

```{r}
df <- tribble(
  ~year,  ~month, ~day,
  2020,  1,       1,
  NA,    NA,      2,
  NA,    NA,      3,
  NA,    2,       1
)
df %>% fill(year, month)
```

All functions that work like this include a call to `tidyselect::vars_select()` that looks somethin like this:

```{r}
find_vars <- function(data, ...) {
  tidyselect::vars_select(names(data), ...)
}

find_vars(df, year, month)
```

I now think that this interface is a mistake, because it suffers from the same problem as `sum()`: we're using a complex interface that only save a little typing. We can eliminate the use of dots by requiring the user to use `c()`. (This change also requires explicit quoting and unquoting of `vars` since we're no longer using `...`.)

```{r}
foo <- function(data, vars) {
  tidyselect::vars_select(names(data), !!enquo(vars))
}

find_vars(df, c(year, month))
```

In other words, I believe that better interface to `fill()` would be:

```{r, eval = FALSE}
df %>% fill(c(year, month))
```

Other functions in tidyverse, like dplyr's scoped verbs `ggplot2::facet_grid()`, use a different approach, requiring the user to explicitly quote the input. I now believe that this is also a suboptimal interface because it is more typing (`var()` is longer than `c()`, and you must quote even single variables), and arguments that require their inputs to be explicitly quoted are rare in the tidyverse. 

```{r, eval = FALSE}
# current interface
dplyr::mutate_at(mtcars, vars(cyl:vs), mean)
# now preferred
dplyr::mutate_at(mtcars, c(cyl:vs), mean)

# current interface
ggplot2::facet_grid(rows = vars(drv), cols = vars(vs, am))
# now preferred
ggplot2::facet_grid(rows = drv, cols = c(vs, am))
```

That said, it is unlikely we will ever change functions, because the benefit is smaller (primarily improved consistency) and the costs are high, as it impossible to switch from an evaluated argument to a quoted argument without breaking backward compatibility in some small percentage of cases.

## Related methods

`dplyr::group_by()` as example of bad name `add` (not `.add`), and `.drp = TRUE` does not give an error. It will create a column, but you might miss that. You could throw an error if any column names starts with a `.`, but that seems overly restrictive, since it's otherwise a good column name. `:=` as a general way out.

What about `mutate()`? 
