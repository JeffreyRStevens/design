# Required args shouldn't have defaults {#args-required}

```{r, include = FALSE}
source("common.R")
```

## What's the problem?

The absence of a default value should imply than an argument is required; the presence of a default should imply that an argument is optional.

When reading a function, it's important to be able to tell at a glance which arguments must be supplied and which are optional. Otherwise you need to rely on the user having carefully read the documentation.

## What are some examples?

*   In `sample()` neither `x` not `size` has a default value, suggesting that
    both are required, and the function would error if you didn't supply them.
    But `size` is optional, determined by a complex conditional.
    
    ```{r}
    sample(1:4)
    sample(4)
    ```

*   `lm()` does not have defaults for `formula`, `data`, `subset`, `weights`, 
    `na.action`, or `offset`. Only `formula` is actually required, and even
    then you get a confusing error message:
    
    ```{r, error = TRUE}
    lm()
    ```
    
*   `help()` and `vignette()` have no default for their first argument, 
    suggesting that they're required. But they're not: calling `help()` or
    `vignette()` without any arguments lists all help files and vignettes 
    respectively.
 
*   In `diag()`, the argument `x` has a default `1`, but it's required: if 
    you don't supply it you get an error:
    
    ```{r, error = TRUE}
    diag()
    diag(x = 1)
    ```
    
    Conversely, `nrow` and `ncol` don't have defaults but aren't required.

*   In `ggplot2::geom_abline()`, `slope` and `intercept` don't have defaults 
    but are not required. If you don't supply them they default to `slope = 1` 
    and `intercept = 0`, *or* are taken from `aes()` if they're supplied
    there.

*   `readr::locale()`. There's a complex dependency between `decimal_mark` and
    `grouping_mark` because they can't be the same value, and the US and Europe
    use different standards.

A common warning sign is the use of `missing()` inside the function.

## What are the exceptions?

There are two exceptions to this rule where in my opionion the benefits outweigh the costs of violating a standard pattern.

### Pair of mututally exclusive arguments {#args-mutually-exclusive}

There are a number of functions that allow you to supply exactly one of two possible arguments:

* `rvest::html_node()` allows you to select HTML nodes either with a `css` 
  selector or an `xpath` expression.
  
* `fct_other()` allows you to either `keep` or `drop` specified factor values.

* `seq_range(x)` allows you create a sequence over the range of `x` by either
  specifying the length of the sequence (with `n`) or the distance between 
  values (with `by`).
  
Only use this technique if there are exactly two possible arguments. If there are more than two, that is generally a sign you should create more functions. See case studies in Chapter \@ref(cs-rep) and Section \@ref(cs-fct-lump) for examples.
 
If you use this technique, use `xor()` and `missing()` to check that exactly one is supplied:

```{r, eval = FALSE}
if (!xor(missing(keep), missing(drop))) {
  stop("Must supply exactly one of `keep` and `drop`", call. = FALSE)
}
```

An in the documentation, make it clear that only one of the pair can be supplied:

```{r}
#' @param keep,drop Pick one of `keep` and `drop`:
#'   * `keep` will preserve listed levels, replacing all others with 
#'     `other_level`.
#'   * `drop` will replace listed levels with `other_level`, keeping all
#'     as is.
```

### One complex argument vs multiple simple arguments {#args-compound}

Less commonly, it can be useful to either supply a single complex argument or mutliple smaller arguments. For example:

* You can call `stringr::str_sub(x, start, end)` or 
  `str_sub(x, cbind(start, end))`

* You can call `stringr::str_replace_all(x, pattern, replacement)` or 
  `str_replace_all(x, c(pattern = replacement))`.

* You can either call `rgb(r, g, b)` or `rgb(cbind(r, g, b))`. See 
  Chapter \@ref(cs-rgb) for more details in case study form.

The most compelling reason to provide this sort of interface is when another function might return a complex output that you want to use as an input. For example, it seems reasonable that you should be able to feed the output of `str_locate()` directly into `str_sub()`:

```{r}
library(stringr)

x <- c("aaaaab", "aaab", "ccccb")
loc <- str_locate(x, "a+b")

str_sub(x, loc)
```

If `str_sub()` didn't optionally accept a single matrix instead of two vector arguments, you'd need to do:

```{r}
str_sub(x, loc[, 1], loc[, 2])
```

### Other exceptions

I'm genuinely conflicted about `purrr::reduce()`: it has an optional details argument called `init`. When supplied, it serves as the initial value for the computation. But any value (including `NULL`) can a valid value. And using a sentinel value for this one case seemed like overkill.
