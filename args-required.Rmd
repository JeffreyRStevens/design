# Required arguments don't have default values {#args-required}

## What's the pattern?

Arguments without a default should be required; required arguments shouldn't have a default. And conversely, arguments with a default are not required; arguments that are not required should have a default.

## Why is this important?

When you scan the arguments of a function, it should be easy to tell which arguments must be supplied and which are optional.


## What are some examples?

*   In `sample()` neither `x` not `size` has a default value, suggesting that
    both are required, and the function would error if you didn't supply them.
    But `size` is in fact optional.

*   `geom_abline()` - probably a sign that it should actually be two functions.

    ```{r, eval = FALSE}
    if (missing(mapping) && missing(slope) && missing(intercept)) {
      slope <- 1
      intercept <- 0
    }
    ```
    
    `geom_jitter()`, `geom_label()`. Use to add new interface on top of old.

*   `.Deprecated()`

## Pair of mututally exclusive arguments

Must supply one of a pair of arguments. `rvest::html_node(css, xpath)` `fct_other(keep, drop)`. `fct_lump(n, prop)`, `seq_range(n, by)`.
    
Possibly too clever? Using `NULL` doesn't improve things because it would imply that neither argument is needed. Maybe should be separate functions? That reduces typing `_prop` vs `, prop = `. Definitely true for `fct_lump()` which time has shown to need much greater extensibility. But seems like overkill for `html_node()`, `fct_other()`, and `seq_range()`

Definitely avoid this technique for greater than two mutually exclusive arguments. e.g. `rep()`: it's really three functions.

Document the arguments together (i.e. `@param css,xpath`) and make it clear that only one can be supplied. Check with something like:

```{r, eval = FALSE}
if (!xor(missing(css), missing(xpath))) {
  abort("Must supply one of `css` or `xpath`")
}
```

## One complex argument vs two simple arguments

`stringr::str_replace()`, `scale_*_manual()` - one richer argument can sometimes serve the role of two simpler arguments. Here you can either supply two vectors, or one vector with names.

Another example is `str_sub()`. You can either call `str_sub(x, start, stop)` or `str_sub(x, cbind(start, stop))`. I'm still not 100% sure of this pattern, but it has the desirable property that the output of `str_locate()` can be fed directly into `str_sub()`.

### `rgb`

```{r, error = TRUE}
library(rlang)

rgba <- function(r, g, b, a = NULL) {
  if (is.data.frame(r)) {
    df <- r
    if (!ncol(df) %in% c(3L, 4L)) {
      abort("If `r` is data frame, it must have 3 or 4 columns.")
    }
    
    if (!missing(b) || !missing(g) || !missing(a)) {
      abort("If `r` is a data frame, `b`, `g`, and `a` must not be set.")
    }
    
    r <- df[[1L]]
    g <- df[[2L]]
    b <- df[[3L]]
    if (ncol(df) == 4) {
      a <- df[[4L]]
    }
  }
  
  rgb(r, g, b, alpha = a, maxColorValue = 255)
}

rgba(16, 16, 16)
rgba(data.frame(16, 16, 16))
rgba(data.frame(16, 16))
rgba(data.frame(16, 16, 16), 1)
```

## Other exceptions

Sometimes, using a missing argument is the best you can do. 

*   `readr::locale()`. There's a complex dependency between `decimal_mark` and
    `grouping_mark` because they can't be the same value. Use missing to 
    automatically set `grouping_mark = "."` if `decimal_mark = ","` and
    vice versa. 

*   `purrr::reduce()` has an optional details argument called `init`. 
    When supplied, it serves as the initial value for the computation. But any 
    value (including `NULL`) can a valid value. Sometimes using a sentinel 
    value can be the right approach.
