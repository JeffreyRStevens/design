# Data, then details {#args-data-details}

```{r, include = FALSE}
source("common.R")
```

(If you're not familiar with the terms "data argument" and "details argument", read Chapter \@ref(call-data-details) before continuing.)

## What's the pattern?

When creating a function, put data arguments before details arguments. 



### Related patterns

It's possible for the data argument to be `...` (i.e. there's an arbitrary number of data arguments). For example, `paste()` allows you to supply any number of strings to `...`, and the details of the concatenation are controlled by `sep` and `collapse`. This pattern is best using sparingly, and is described in more detail in Chapter \@ref(dots-data). 

`...` can also be used to capture details arguments and pass them on to other functions. See Chapters \@ref(dots-lhs) and \@ref(dots-inspect) to how to use `...` as safely as possible in this situation.

## What happens if I don't do it?

One larger family of functions in base R are the functions that tend not to follow this are the string manipulation functions. For example, `grepl(pattern, x)` returns a logical vector the same length as `x` containing `TRUE` wherever `pattern` is matched. Here, `x` is the data argument (it's the character vector of strings to compare), and `pattern` is the data argument. 

`lm()`

`replicate()`

`setNames()`

See also `mapply()` vs. `pmap()` as discussed in Chapter \@ref(mapply-pmap).

`purrr::reduce()` has an optional details argument called `init`. When supplied, it serves as the initial value for the computation. But any value (including `NULL`) can a valid value. Sometimes using a sentinel value can be the right approach.


## Case study: `mapply()` vs. `pmap()`

`mapply()` and `Map()` - take arguments in `...` so have to either put `FUN` first so it can be used unnamed, or force the use always name it.

## How do I recover?

