# Magical default arguments {#args-magical-defaults}

```{r, include = FALSE}
source("common.R")
```

## What's the problem?

Some functions have default values that return different things when you run them interactively:

*   In `hist()`, the default value of `xlim` is `range(breaks)`, and the default
    value for `breaks` is `"Sturges"`. `range("Sturges")` returns 
    `c("Sturges", "Sturges")` which clearly doesn't make sense.
  
*   In previous versions of readr, `read_csv(progress = show_progress())`, 
    and `show_progress()` was an internal function.

*   In `abind::abind()` the default value of `along` is `N`, which is computed
    inside the function.
  
*   `diag()` shows another instance of the same underlying problem:
    the default value for `x` is `1`, but you get a different
    result if you set it explicitly:

    ```{r, error = TRUE}
    diag()
    diag(x = 1)
    ```

If the default value of an argument behaves differently when supplied explicitly,  we say it has a __magical default__.

## What causes the problem?

There are two main sources: 

*   Using `missing()`

    ```{r}
    f1 <- function(x = 1) {
      if (missing(x)) {
        2
      } else {
        x
      }
    }
    
    f1()
    f1(1)
    ```

*   Using a default argument that is evaluated inside of the function:

    ```{r}
    f2 <- function(x = y) {
      y <- 2
      x
    }
    
    y <- 1
    f2()
    f2(y)
    ```

## How do I remediate the problem?

This problem is generally easy to avoid for new functions:

* Never use `missing()`. (The only exception is described in Chapter
  \@ref(args-missing)).
  
* Never use defaults that depend on variables defined inside the function.

If you have a made a mistake in an older function you can generally remediate it by using an explicit `NULL`, as described in Chapter \@ref(arg-defaults-short).

```{r}
`%||%` <- function(x, y) if (is.null(x)) y else x

f1_better <- function(x = NULL) {
  if (is.null(x)) {
    2
  } else {
    x
  }
}
f1_better()
f1_better(1)

f2_better <- function(x = NULL) {
  y <- 2
  x <- x %||% y
  
  x
}

f2_better()
f2_better(1)
```

These modifications generally don't affect the interface of the function, except that `NULL` is now a permissible input. This expands the API, so shouldn't break existing code.

There's one exception: functions like `data.frame()` where `NULL` is a permissible value, and it does something different to the default:

```{r}
x <- setNames(nm = letters[1:3])
data.frame(x)
data.frame(x, row.names = NULL)
```

To remediate a function of this nature, you'll need to use a sentinel object.

```{r}
sentinel <- function() structure(list(), class = "sentinel")
is_sentinel <- function(x) inherits(x, "sentinel")

data.frame_better <- function(..., row.names = sentinel()) {
  if (is_sentinel(row.names)) {
    # old default behaviour
  }
}
```
