# Magical default arguments {#args-magical-defaults}

```{r, include = FALSE}
source("common.R")
```

```{r, eval = FALSE, include = FALSE}
source("fun_def.R")

funs <- c(pkg_funs("base"), pkg_funs("stats"), pkg_funs("utils"))
funs %>% funs_formals_keep(~ is_symbol(.x) && !is_missing(.x))
pkg_funs("base") %>% funs_body_keep(has_call, "missing")
```

## What's the problem?

Some functions have default values that return different things when you run them interactively:

*   In `hist()`, the default value of `xlim` is `range(breaks)`, and the
    default value for `breaks` is `"Sturges"`. `range("Sturges")` returns 
    `c("Sturges", "Sturges")` which doesn't work when supplied explicitly:
    
    ```{r, error = TRUE}
    args(hist)
    hist(1:10, xlim = c("Sturges", "Sturges"))
    ```

*   In `Vectorize()`, the default argument for `vectorize.args` is 
    `arg.names`, but this is only defined inside the body of `Vectorize`.
    If you supply it explicitly you get an error.

    ```{r, error = TRUE}
    args(Vectorize)
    Vectorize(rep.int, vectorize.args = arg.names)
    ```

If the default value of an argument behaves differently when supplied explicitly,  we say it has a __magical default__.

## What causes the problem?

There are two main sources: 

*   Using `missing()`

    ```{r}
    f1 <- function(x = 1) {
      if (missing(x)) {
        2
      } else {
        x
      }
    }
    
    f1()
    f1(1)
    ```

*   Using a default argument that is evaluated inside of the function:

    ```{r}
    f2 <- function(x = y) {
      y <- 2
      x
    }
    
    y <- 1
    f2()
    f2(y)
    ```

## Are there exceptions?

Sometimes it's useful to default one argument to the same value as another. 

* `set_names()`. 
* `merge()`
* `sample.int()`, `factor()`

Should always be argument that comes before, not after, unlike `file.copy()` where `overwrite = recursive` comes before the `recursive` argument is defined.

```{r}
args(file.copy)
```

`setNames()`.

## How do I remediate the problem?

This problem is generally easy to avoid for new functions:

* Never use `missing()`. (The only exception is described in Chapter
  \@ref(args-missing)).
  
* Never use defaults that depend on variables defined inside the function.

If you have a made a mistake in an older function you can generally remediate it by using an explicit `NULL`, as described in Chapter \@ref(arg-defaults-short).

```{r}
`%||%` <- function(x, y) if (is.null(x)) y else x

f1_better <- function(x = NULL) {
  if (is.null(x)) {
    2
  } else {
    x
  }
}
f1_better()
f1_better(1)

f2_better <- function(x = NULL) {
  y <- 2
  x <- x %||% y
  
  x
}

f2_better()
f2_better(1)
```

These modifications generally don't affect the interface of the function, except that `NULL` is now a permissible input. This expands the API, so shouldn't break existing code.

There's one exception: functions like `data.frame()` where `NULL` is a permissible value, and it does something different to the default:

```{r}
x <- setNames(nm = letters[1:3])
data.frame(x)
data.frame(x, row.names = NULL)
```

To remediate a function of this nature, you'll need to use a sentinel object.

```{r}
sentinel <- function() structure(list(), class = "sentinel")
is_sentinel <- function(x) inherits(x, "sentinel")

data.frame_better <- function(..., row.names = sentinel()) {
  if (is_sentinel(row.names)) {
    # old default behaviour
  }
}
```
