# Optional args have defaults {#sec-def-required}

```{r}
#| include = FALSE
source("common.R")
```

## What's the pattern?

An argument should have a default if and only if it's optional.
In other words: the absence of a default implies than an argument is required; the presence of a default implies that an argument is optional.
There are two exceptions: when a pair of arguments are mutually exclusive (i.e. you must supply one or the other but not both), or when you can supply one complex object instead of two or more simple objects.

This simple convention ensures that you can tell which arguments are optional and which arguments are required from a glance at the function signature.
Otherwise you need to rely on the user carefully reading the documentation.

Additionally, if you want to provide helpful error messages, you'll need to explicitly code them yourself, rather than relying on R's defaults.

## What are some examples?

This is a straightforward convention that the vast majority of functions follow.
There are a few exceptions that exist in base, mostly for historical reasons.
Here are a couple of examples:

-   In `sample()` neither `x` not `size` has a default value:

    ```{r}
    args(sample)
    ```

    This suggests that `size` is required, but it's actually optional:

    ```{r}
    sample(1:4)
    sample(4)
    ```

-   `lm()` does not have defaults for `formula`, `data`, `subset`, `weights`, `na.action`, or `offset`.

    ```{r}
    args(lm)
    ```

    But only `formula` is actually required:

    ```{r}
    x <- 1:5
    y <- 2 * x + 1 + rnorm(length(x))
    lm(y ~ x)
    ```

This pattern is rare in the tidyverse but there are still a few cases.
For example, in `ggplot2::geom_abline()`, `slope` and `intercept` don't have defaults but are not required.
If you don't supply them they default to `slope = 1` and `intercept = 0`, *or* are taken from `aes()` if they're provided there.
8

## What are the exceptions?

There are two exceptions to this rule:

-   A pair of arguments that provide an alternative specification for the same underlying concept.
    It is only ever possible to supply one argument.

-   When you can either supply one complex object, or a handful of simpler objects.

In both cases, I believe the benefits outweigh the costs of violating a standard pattern.

### Pair of mutually exclusive arguments {#sec-args-mutually-exclusive}

<!-- TODO : make this its own chapter. Needs more space to breath -->

A number of functions that allow you to supply exactly one of two possible arguments:

-   `read.table()` allows you to supply data either with a path to a `file`, or inline as `text`.

-   `rvest::html_element()` allows you to select HTML elements either with a `css` selector or an `xpath` expression.

-   `forcats::fct_other()` allows you to either `keep` or `drop` specified factor values.

If you use this technique, use `xor()` and `missing()` to check that exactly one argument is supplied:

```{r}
#| error: true

fct_drop <- function(f, drop, keep) {
  if (!xor(missing(keep), missing(drop))) {
    stop("Must supply exactly one of `keep` and `drop`")
  }  
}
fct_drop(factor())

fct_drop(factor(), keep = "a", drop = "b")
```

Or the helper `rlang::check_exclusive()`:

```{r}
#| error: true

fct_drop <- function(f, drop, keep) {
  rlang::check_exclusive(drop, keep)
}
fct_drop(factor())

fct_drop(factor(), keep = "a", drop = "b")
```

And in the documentation, make it clear that only one of the pair can be supplied:

```{r}
#' @param keep,drop Pick one of `keep` and `drop`:
#'   * `keep` will preserve listed levels, replacing all others with 
#'     `other_level`.
#'   * `drop` will replace listed levels with `other_level`, keeping all
#'     as is.
```

This technique should only be used for are exactly two possible arguments.
If there are more than two, that is generally a sign you should create more functions.
See case studies in @sec-cs-rep and @sec-cs-fct-lump for examples.

### One compound argument vs multiple simple arguments {#sec-args-compound}

A related, if less generally useful, form is to allow the user to supply either a single complex argument or several smaller arguments.
For example:

-   `rgb(cbind(r, g, b))` is equivalent to `rgb(r, g, b)` (See @sec-cs-rgb for more details).

-   `options(list(a = 1, b = 2))` is equivalent to `options(a = 1, b = 2)`.

-   `stringr::str_sub(x, cbind(start, end))` is equivalent to `str_sub(x, start, end)`.

The most compelling reason to provide this sort of interface is when another function might return a complex output that you want to use as an input.
For example, it seems reasonable that you should be able to feed the output of `str_locate()` directly into `str_sub()`:

```{r}
library(stringr)

x <- c("aaaaab", "aaab", "ccccb")
loc <- str_locate(x, "a+b")

str_sub(x, loc)
```

But equally, it would be a bit weird to have to provide a matrix when subsetting with known positions:

```{r}
str_sub("Hadley", cbind(2, 4))
```

So `str_sub()` allows either individual vectors supplied to `start` and `end`, or a two-column matrix supplied to `start`.

To implement in your own functions, you should branch on the type of the first argument:

```{r}
str_sub <- function(string, start, end) {
  if (is.matrix(start)) {
    if (!missing(end)) {
      stop("`end` must be missing when `start` is a matrix", call. = FALSE)
    }
    if (ncol(start) != 2) {
      stop("Matrix `start` must have exactly two columns", call. = FALSE)
    }
    stri_sub(string, from = start[, 1], to = start[, 2])
  } else {
    stri_sub(string, from = start, to = end)
  }
}
```

And make it clear in the documentation:

```{r}
#' @param start,end Integer vectors giving the `start` (default: first)
#'   and `end` (default: last) positions, inclusively. Alternatively, you
#'   pass a two-column matrix to `start`, i.e. `str_sub(x, start, end)`
#'   is equivalent to `str_sub(x, cbind(start, end))`
```

(If you look at `string::str_sub()` you'll notice that `start` and `end` do have defaults; I think this is a mistake because `start` and `end` are important enough that the user should always be forced to supply them.)
