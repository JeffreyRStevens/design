# Spooky action

There is no limitation to what an R function or script can do. After you call `draw_plot()` or `source("analyse-data.R")`, you could discover that all the variables in your global environment might be deleted, or that 1000 new files have been created on your desktop. These actions are extremely surprising, because you don't expect a function or script to destructively modify the environment. 

Deleting variables and creating files on your desktop are obviously surprising even if you've only just started using R. But there are other actions that are less obviously destructive, and only start to become surprising as your mental model R matures. These include things like:

* Attaching packages with `library()`. For example,
  `ggplot2::geom_map()` used to call `library(maps)` in order
  to get map data. This seems harmless, but if you were using purrr,
  it breaks `map()` because it's now overridden by `maps::map()`
  (which draws a map, rather than mapping a function over a vector).
  
* Installing packages with `install.packages()`. If a script
  needs dplyr to work, and it's not installed, it seems harmless to
  install it on behalf of the user. But installing a new package can
  upgrade existing packages, which might break code in other projects.

* Deleting objects in the global environment with `rm(list = ls())`. 
  This might seem harmless to you because you who always runs scripts in a
  new R session, and you always make sure that all objects can easily 
  be re-created from a script. But not everyone works this way, and you
  might cause pain for someone with a less polished workflow.

Collectively, we call such side-effects "spooky actions" because the connection between action (calling a function or sourcing a script) and result (deleting objects or upgrading packages) is surprising. It's like flipping a light-switch and discovering that shower starts running, or having a poltergeist that rearranges the contents of your kitchen cupboards when you're not looking.

Because R doesn't constrain the potential scope of functions and scripts, *you* have to. By restraining your possible actions in functions and scripts, you will create code that is less suprising to other R user. At first, this might seem like tedious busywork. You might find that spooky action is convenient in the moment, and you might convince yourself that it’s necessary or a good idea. But as you share your code with more people and run more code that has been shared with you, you'll find spooky action to get more and more surprising and frustrating.

## What is the underlying principle?

We can make the notion of spooky action more precise by thinking about trees. There are important types of trees:

* The tree formed by files and directories.

* The tree of environments created by function calls.

Generally, code should only affect the tree beneath where it lives. You should avoid modifying up the tree or across into a different branch:

*   A script should only read from and write to directories beneath the
    directory where it lives. This implies that installing packages is
    a spooky action (unless it's a project specific package), and also
    explains why you shouldn't create files in central locations.
    
    This rule can be relaxed in two small ways. Firstly, if the script
    lives in a project, it's ok to read from and write to anywhere in the
    project (i.e. a file in `R/` can read from `data-raw/` and write to
    `data/`). Secondly, it's always ok to write to the sessions specific
    temporary directory accessed with `tempdir()`.

*   A function should only create and modify variables in its own 
    environment or functions that it calls. This is explains why you shouldn't 
    attach packages (because that changes environments in the 
    [search path](https://adv-r.hadley.nz/environments.html#search-path)),
    why you shouldn't delete variables with `rm(list = ls())`,
    or assign to variables that you didn't create with `<<-`.

## How can I remediate spooky actions?

If you have read the above cautions, and still want to proceed, there are three ways you can make the spooky action as safe as possible:

* Make the action less spooky by giving it a name that clearly implies it's 
  action.
  
* Explicitly check with the user before proceeding.

* Advertise what's happening so the action isn't silent.

### Make action clear

The easiest way to make actions not spooky is by making it clear what's going to happen from the outside. It is perfectly fine for function or script to have actions outside of its usual scope if that is it's explicit in its name:

* It's ok for `<-` to modify the global environment, because that is its one 
  job. It's ok for `save_output(path)` to create files in path because it's 
  clear from the name.

* It's fine for `install.packages()` to modify files outside of the current
  working directory because it's designed specifically to install packages.

* It's ok for `source("class-setup.R")` to install packages because the intent 
  of a setup script is to get your computer into the same state as someone 
  else's (but be aware by doing this, you might break other projects).

Note that it's the name that's important - it's fine for `install.packages()` to install packages, but it's not ok as soon as it's hidden behind even a very simple wrapper:

```{r}
current_time <- function() {
  if (!requireNamespace("lubridate", quietly = TRUE)) {
    install.packages("lubridate")
  }
  lubridate::now()
}
current_time()
```

### Ask for confirmation

If you believe the spooky action is important, and you can't pull it out into a top-level function or script specifically designed for a purpose, make sure that that you confirm with the user that it's ok. 

The code below shows how you might do so when installing a package:

```{r}
install_if_needed <- function(package) {
  if (requireNamespace(package, quietly = TRUE)) {
    return(invisible(TRUE))
  }
  
  if (!interactive()) {
    stop(package, " is not installed", call. = FALSE)
  }
  
  title <- paste0(package, " is not installed. Do you wish to install now?")
  if (menu(c("Yes", "No"), title = title) != 1) {
    stop("Confirmation not recieved", call. = FALSE)
  }
  
  invisible(TRUE)
}
```

Note the use of `interactive()` here: if the user is not in an interactive setting (i.e. the code is being run with `Rscript`) and we can not get explicit confirmation, we shouldn't make any changes. Also that all failures are errors: this ensures that the remainder of the function or script does not run if the user doesn't confirm.

Ideally this function would also clearly describe the consequences of your decision. For example, it would be nice to know if it will download a significant amount of data (since you might want to wait until your at a fast connection if downloading a 1 Gb data package), or if it will upgrade existing packages (since that might break other code).

### Advertise the side-effects

If you can't get explicit confirmation from the user, at the very minimum you should clearly advertise what is happening. For example, when you call `install.packages()` it notifies you:

```{r, eval = FALSE}
install.packages("dplyr")
#> Installing package into ‘/Users/hadley/R’
#> (as ‘lib’ is unspecified)
#> Trying URL 'https://cran.rstudio.com/bin/macosx/el-capitan/contrib/3.5/dplyr_0.8.0.1.tgz'
#> Content type 'application/x-gzip' length 6587031 bytes (6.3 MB)
#> ==================================================
#> downloaded 6.3 MB
```

However, this message could do with some work:

* It says installing "package", without specifying which package (so if
  this is called inside another function it won't be informative).
  
* It doesn't notify me which dependencies it's also going to update.

* It notifies me of the url it's downloading from, which I don't care about,
  and it only notifies me about the size when it's finished downloading, 
  by which time it too late to stop it.

I would instead write something like this:

```{r, eval = FALSE}
install.packages("dplyr")
#> Installing package dplyr to `/Users/hadley/R`
#> Also installing 3 dependencies: glue, rlang, R6
```

We'll come back to the issue of informing the user in ...

## Case studies

### `save()` and `load()`

`load()` is one of the few functions in base R that have spooky action.

```{r, include = FALSE}
if (!file.exists("spooky-action.rds")) {
  x <- 10
  y <- 100
  save(x, y, file = "spooky-action.rds")
  rm(x, y)
}
```

```{r}
x <- 1
load("spooky-action.rds")
x
```

You can make it less spooky by supplying `verbose = TRUE`. Here we now learn that it also loaded a `y` object

```{r}
load("spooky-action.rds", verbose = TRUE)
y
```

But generally, I'd avoid `save()` and `load()` altogether, and instead use `saveRDS()` and `readRDS()`, which read and write individual R objects to individual R files and work with `<-` so that assignment is no longer hidden.

```{r}
saveRDS(x, "x.rds")
x <- readRDS("x.rds")
```
```{r}
unlink("x.rds")
```


(readr provides `readr::read_rds()` and `readr::write_rds()` if the inconsistent naming conventions bother you like they bother me.)

### usethis

All the functions in usethis are specifically for modifying your computing environment. They designed to be used interactively, but shouldn't be called automatically (i.e. it's fine to wrap them in a function that is then called by the user, but you shouldn't generally run them in a script)

This poses some challenges for internal reuse.

### `assign()` in a for loop

It's not uncommon for people to ask: how do you create multiple objects from for a loop? Maybe you have a vector of file names, and want to read them into individual objects:

```{r, eval = FALSE}
paths <- c("a.csv", "b.csv", "c.csv")
names <- c("a", "b", "c")

for (i in seq_along(paths)) {
  assign(names[[i]], read.csv(paths[[i]]))
}
```

The main problem with this approach is that it does not faciliate computation. Say you now wanted to figure out how many rows are in each of the data frames? You'd need to use `get()` to find the object:

```{r, eval = FALSE}
lengths <- numeric(length(names))
for (i in seq_along(names)) {
  lengths[[i]] <- nrow(get(names[[i]]))
}
```

If you instead save the files into a list:

```{r, eval = FALSE}
library(purrr)

files <- map(paths, read.csv)
names(files) <- names
```

You can still access individual files easily (with e.g. `files$a`), but now when you come to compute the number of rows, you can use an existing helper:

```{r, eval = FALSE}
map_int(files, nrow)
```

This obviously requires that you learn some new tools - but learning `map()` and `map_int()` and going to pay off in many more situations than `assign()` and `get()` will.

Wrapping a pattern like this up into a function is even more dangerous, because now you're assigning into an environment that you don't own, and you'll need to be very carefuly to avoid overriding existing objects. 

### `<<-` with `lapply()`

* `lapply()` + `<<-` vs `counter()`
  https://stackoverflow.com/questions/2656792
  https://stackoverflow.com/questions/52565742