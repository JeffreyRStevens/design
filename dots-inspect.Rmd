# Inspect the dots

```{r, include = FALSE}
source("common.R")
```

## What's the pattern?

Whenever you use `...` in an S3 generic, you should inspect the dots to make sure that every argument is used.

The same approach can also be used when passing `...` on down to another function that 

## What happens if I don't do it?

An important application of `...` is in S3 generics. If a generic has `...` in its arguments, methods can add additional arguments. This adds considerably flexibility, but comes at a price: misspelling an argument name will cause it to be silently ignored. For example:

```{r}
weighted.mean(c(1, 0, -1), wt = c(10, 0, 0))
```

## What are the advantages?


## How do I do it?

Accurately detecting this problem is hard because no one place has all the information needed to tell if an argument is superfluous or not (the precise details are beyond the scope of this text). Instead the ellipsis package takes advantage of R's [lazy evaluation][lazy-eval] and inspects the internal components of `...` to see if their evaluation has been forced.

```{r, error = TRUE}
weighted_mean <- function(x, w, ...) {
  ellipsis::check_dots_used()
  UseMethod("weighted_mean")
}

weighted_mean.numeric <- function(x, w = NULL, ..., na.rm = FALSE) {
  if (is.null(w)) {
    return(mean(x))
  }
  
  keep <- w != 0
  if (na.rm) {
    keep <- keep & !is.na(x)
  }
  
  w <- w[keep]
  x <- x[keep]

  sum(x * w) / sum(w)
}

weighted_mean(c(1, 0, -1), wt = c(10, 0, 0))
```


```{r}
safe_cut <- function(x, breaks, ..., right = TRUE) {
  ellipsis::check_dots_used()
  UseMethod("safe_cut")
}

safe_cut.numeric <- function(x, breaks, ..., right = TRUE, include.lowest = FALSE) {
  cut(x, breaks = breaks, right = right, include.lowest = include.lowest)
}

safe_cut.Date <- function(x, breaks, ...., right = TRUE, start.on.monday = TRUE) {
  cut(x, breaks = breaks, right = right, start.on.monday = start.on.monday)
  
}
```

Note that this technique will not work if a method doesn't evaluated its arguments (i.e. it quotes them using `rlang::enquo()` or similar). However, quoting vs. evaluating is part of the overall interface of the function, so it's fine for the author of the generic to make that decision for all method authors. (And this is a relatively rare case anyway.)

## What are other uses?

This same technique can also be used when you are wrapping other functions. For example, `stringr::str_sort()` takes `...` and passes it on to `stringi::stri_opts_collator()`. As of March 2019, `str_sort()` looked like this:

```{r}
str_sort <- function(x, decreasing = FALSE, na_last = TRUE, locale = "en",  numeric = FALSE, ...) 
{
    stringi::stri_sort(x, 
      decreasing = decreasing, 
      na_last = na_last, 
      opts_collator = stringi::stri_opts_collator(
        locale, 
        numeric = numeric, 
        ...
      )
    )
}
```

```{r}
x <- c("x1", "x100", "x2")
str_sort(x)
str_sort(x, numeric = TRUE)
```

This is wrapper is useful because it decouples `str_sort()` from the `stri_opts_collator()` meaning that if `stri_opts_collator()` gains new arguments users of `str_sort()` can take advantage of them immediately. But most of the arguments in `stri_opts_collator()` are sufficiently arcane that they don't need to be exposed directly in stringr, which is designed to minimise the cognitive load of the user, by hiding some of the full complexity of string handling.

(The importance of the `locale` argument comes up in "hidden inputs", Chapter \@ref(hidden-inputs).)

However, `stri_opts_collator()` deliberately ignores any arguments in `...`. This means that misspellings are silently ignored:

```{r}
str_sort(x, numric = TRUE)
```

We can work around this behaviour by adding `check_dots_used()` to `str_sort()`:

```{r, error = TRUE}
str_sort <- function(x, decreasing = FALSE, na_last = TRUE, locale = "en",  numeric = FALSE, ...) 
{
    ellipsis::check_dots_used()
  
    stringi::stri_sort(x, 
      decreasing = decreasing, 
      na_last = na_last, 
      opts_collator = stringi::stri_opts_collator(
        locale, 
        numeric = numeric, 
        ...
      )
    )
}

str_sort(x, numric = TRUE)
```

In this case it's slightly better to figure out why `stri_opts_collator()` ignores `...` in the first place. You can see that discussion at <https://github.com/gagolews/stringi/issues/347>.

`install_github()` -> `install.packages()` -> `download.file()`. https://github.com/r-lib/ellipsis/issues/10#issuecomment-469915847. If not, call `ellipsis::check_used_dots()`.

[lazy-eval]: https://adv-r.hadley.nz/functions.html#lazy-evaluation